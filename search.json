[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Métodos Numéricos y Probabilidades 2025",
    "section": "",
    "text": "Motivación\nLas (los) físicas (os) siempre han llevado la punta de lanza del desarrollo tecnológico. Desde la revolución industrial hasta el desarrollo de la computación cuántica, los (las) físicos (as) han tenido un manejo profundo de la tecnología que les permite hacer nuevos descubrimientos o inventos. Esto es aún más cierto en el siglo XXI, en el cual la mayoría de las (los) licenciadas (os) en física de los países de alto desarrollo tecnológico trabajan en el sector privado creando y mejorando las herramientas informáticas, financieras y estadísticas que usamos todos los días. Esto se debe a que a lo largo de sus carreras adquieren un conocimiento íntimo de la tecnología de punta al intentar aplicarla a problemas científicos abiertos.\nSon muy pocos los problemas que admiten una solución sencilla de lápiz y papel. Para la mayoría de nuevos desarrollos es necesario usar el computador. Esto es verdad tanto para analizar los datos obtenidos en los experimentos, como para resolver las ecuaciones diferenciales que aparecen en la física teórica. Incluso quienes hacen un trabajo puramente analítico se apoyan en herramientas computacionales para los cálculos que son cada vez más complejos.\nEn este curso aprenderemos a usar las herramientas numéricas disponibles para atacar problemas físicos y al hacerlo aprenderemos a usar plataformas, paquetes y lenguajes de programación modernos.\n\n\nLecturas Sugeridas\n\nR. L. Burden, D. J. Faires, A. M. Burden, “Numerical Analysis”, 10ma edición, Cengage Learning, 2016 (NA)\nT. A. Driscoll, R. J. Braun, “Funamentals of Numerical Computation”, 2da edición, SIAM, 2022 (FNC)\nB. R. Martin, “Statistics for Physical Sciences”. Elsevier, 2012 (S)\nA. B. Downey, “Think Python,” 2da edición, O’Reilly, 2015. (TP)\n\n\n\nPrograma\nSe indican las fechas y temas de cada clase, junto con las secciones de los libros a las que corresponden.\n1- Introducción\n\n¿Cómo funciona una CPU?, 7 de agosto.\nRepaso de Python, 12 de agosto.\nNumpy y arrays, 14 de agosto.\nRepresentación binaria de números decimales, número de condicionamiento 19 de agosto\nAlgoritmos y estabilidad 21 de agosto\n\n2- Probabilidades\n\nPropiedades básicas de la probabilidad, 26 de agosto\nDistribuciones de probabilidad, 28 de agosto\nVarias variables aleatorias, 2 de septiembre\nSuma de muchas variables aleatorias y teorema central del límite, 4 de septiembre\nInformación y entropía, 9 de septiembre\n\nPrueba: 23 de septiembre\n3- Cálculo numérico\n\nSolución de sistemas de ecuaciones lineales: Inversión de matrices, 11 de septiembre\nBúsqueda de raíces: Métodos de bisección y Newton, 25 de septiembre\nInterpolación, 30 de septiembre\nDerivadas numéricas y autodiferenciación, 2 de octubre\nIntegración numérica simple y adaptativa, 7 de octubre\nIntegración numérica por método de Gauss, 9 de octubre\n\nPrueba: 16 de octubre\n4- Solución numérica de ecuaciones diferenciales ordinarias\n\nMétodos de Euler y Taylor, 14 de octubre\nMétodo de Runge Kutta, 21 de octubre\nMétodo de Runge Kutta adaptativo, 23 de octubre\nMétodos de múltiples pasos y método de Adams, 4 de noviembre\nSistemas de ecuaciones diferenciales y ecuaciones de alto orden, 6 de noviembre\n\nPrueba: 13 de noviembre\n5- Optimización y otros algoritmos importantes\n\nAjuste de curvas y bondad de ajuste, 11 de noviembre\nOptimización por descenso de gradiente, 18 de noviembre\nIntroducción a las redes neuronales, 20 de noviembre\nMétodos de Monte Carlo y/o transformada rápida de Fourier, 25 de noviembre\n\nRecuperativa: 27 de noviembre\nExamen: Definido por Instituto\n\n\nEvaluación\nLa evaluación se hará por tareas y pruebas.\nAl final de cada clase habrán 5 tareas para un total de 10 tareas cada dos clases. De estas 10 tareas se le asignará de forma aleatoria una tarea a cada estudiante. De esta manera el estudiante deberá entregar aproximadamente 11 tareas a lo largo del curso. El 25% de la nota final es el promedio de las notas de las tareas.\nLas tareas se entregan dos clases después de haber sido asignadas.\nSe evaluará lo siguiente:\nEl código funciona (4 puntos): Si el código pedido hace lo que deberíacumplir sin errores en ningún caso, la estudiante obtendrá los 4 puntos. Si existen casos especiales en los cuales el código no funciona, pero funciona en la mayoría de los casos, la estudiante obtendrá 3 puntos. Si el código no funciona pero el error es menor (algún detalle de sintaxis, alguna variable mal nombrada, alguna excepción de Python difícil de prever), el estudiante obtendrá 2 puntos. Si el código no funciona el estudiante obtendrá 1 punto. Si no entrega la tarea el estudiante obtendrá 0 puntos.\nEl código es legible (+2 puntos): Si el código está comentado en cada paso el estudiante obtendrá +1 punto. Si el código es fácil de entender, está bien organizado, las variables tienen nombres que corresponden a lo que representan la estudiante obtendrá +1 punto.\nLa nota de la tarea = # de puntos + 1.\nLa otra mitad de la nota será el promedio de tres pruebas realizadas a lo largo del semestre. Las pruebas consisten en ejercicios sencillos basados en lo visto en clase y en las tareas.\nLas siguientes son las fechas de las pruebas:\nPrueba: 10 de septiembre Prueba: 5 de noviembre Prueba: 25 de noviembre Recuperativa: 26 de noviembre Examen: 10 de diciembre\n\n\nNormas\nLos estudiantes no están obligados a ir a las ayudantías, pero obviamente quien asista estará mejor preparado para las pruebas y los exámenes porque sabrá cuáles son los problemas que entran. Las tareas se entregarán en formato electrónico por medio de la plataforma GitHub. Se usa esta en vez del Aula Virtual dado su uso extenso en el mundo profesional.\nHágale preguntas al profesor a la dirección jorge.norena@pucv.cl, o en el horario de atención. Hacer preguntas ayuda a aprender y hace más ameno el trabajo del profesor. La clase empieza puntual si hay al menos un estudiante presente, por respeto a los que llegan a tiempo.\n\n\nRecomendaciones\nPOR FAVOR HAGAN PREGUNTAS DURANTE LA CLASE, LAS AYUDANTÍAS, POR CORREO ELECTRÓNICO, EN LOS HORARIOS DE ATENCIÓN Y POR CUALQUIER OTRO MEDIO QUE PUEDA.\nSi quiere conversar hágalo por chat en su teléfono para que el ruido no distraiga a los demás. Use el teléfono para tomarle fotos a la pizarra cuando quiera recordar algo.\n\n\nHorarios de atención y contacto\nPuede en cualquier momento hacer preguntas por correo electrónico.\nCorreo electrónico profesor: jorge.norena@pucv.cl Correo electrónico de la ayudante:\nTambién puede pasar por la oficina del profesor en cualquier momento.\nEl horario de atención reservado es una hora después de cada clase."
  },
  {
    "objectID": "02_python.html",
    "href": "02_python.html",
    "title": "Repaso de Python",
    "section": "",
    "text": "print(\"Normalmente uno escribe: Hola, Mundo!\")\n\nNormalmente uno escribe: Hola, Mundo!\n\n\n\n2 + 3\n\n5\n\n\n\n2 * 3\n\n6\n\n\n\n2/3\n\n0.6666666666666666\n\n\n\n2-3\n\n-1\n\n\n\n2//3\n\n0\n\n\n\n2%3\n\n2\n\n\n\n2**3\n\n8\n\n\n\n\n\n\ntype(\"Normalmente uno escribe: Hola, Mundo!\")\n\nstr\n\n\n\ntype(2)\n\nint\n\n\n\ntype(3.1)\n\nfloat\n\n\n\n\n\n\nmensaje = 'Normalmente uno escribe: Hola, Mundo!'\n\n\nmensaje\n\n'Normalmente uno escribe: Hola, Mundo!'\n\n\n\nn = 17\n\n\nn\n\n17\n\n\n\ncasi_pi = 3.1416\n\n\n\n\n\ncasi_pi + n\n\n20.1416\n\n\n\nprint(n)\n\n17\n\n\n\n\n\nEn Python los operadores tienen jerarquía: - Exponenciación - Multiplicación y división - Suma y resta Primero se evalúan los de mayor jerarquía. Cuando hay dos iguales se evalúa de izquierda a derecha.\nCuando haya dudas, usar paréntesis, por ejemplo \\(2(3 - 1) = 4\\)\n\n2*(3 - 1)\n\n4\n\n\nLo siguiente es \\(1 + 2^3 = 9\\), muy distinto de \\((1 + 2)^3 = 27\\)\n\n1 + 2**3\n\n9\n\n\nEsto es \\(2\\times 3^2 = 18\\) muy distinto de \\((2\\times 3)^2 = 36\\)\n\n2*3**2\n\n18\n\n\n\n2*3 - 1\n\n5\n\n\n\n6 + 4/2\n\n8.0\n\n\n¡Cuidado! Si quiero escribir \\(4/(2\\times 2) = 1\\) no lo puedo hacer de esta manera.\n\n4/2*2\n\n4.0\n\n\n\n4/2/2\n\n1.0\n\n\n\n4/(2*2)\n\n1.0\n\n\n\n\n\n\n# Este código no hace nada, es puro comentario\n\n\n# Este código hace algo muy básico. Convierto mi pc en una calculadora cara\n2 + 3\n\n5\n\n\n\n\n\nError de sintaxis\n\n2 +\n\n\n  Cell In[29], line 1\n    2 +\n       ^\nSyntaxError: invalid syntax\n\n\n\n\nOtros tipos de errores\n\nprint(2/0)\n\n\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nCell In[30], line 1\n----&gt; 1 print(2/0)\n\nZeroDivisionError: division by zero\n\n\n\n\nfor i in j:\n    print(i)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[31], line 1\n----&gt; 1 for i in j:\n      2     print(i)\n\nNameError: name 'j' is not defined\n\n\n\n\ndef mistake(n):\n    for i in range(n):\n        print(10/i)\n\n\nmistake(10)\n\n\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nCell In[33], line 1\n----&gt; 1 mistake(10)\n\nCell In[32], line 3, in mistake(n)\n      1 def mistake(n):\n      2     for i in range(n):\n----&gt; 3         print(10/i)\n\nZeroDivisionError: division by zero",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#mi-primer-código",
    "href": "02_python.html#mi-primer-código",
    "title": "Repaso de Python",
    "section": "",
    "text": "print(\"Normalmente uno escribe: Hola, Mundo!\")\n\nNormalmente uno escribe: Hola, Mundo!\n\n\n\n2 + 3\n\n5\n\n\n\n2 * 3\n\n6\n\n\n\n2/3\n\n0.6666666666666666\n\n\n\n2-3\n\n-1\n\n\n\n2//3\n\n0\n\n\n\n2%3\n\n2\n\n\n\n2**3\n\n8",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#tipos-de-valores",
    "href": "02_python.html#tipos-de-valores",
    "title": "Repaso de Python",
    "section": "",
    "text": "type(\"Normalmente uno escribe: Hola, Mundo!\")\n\nstr\n\n\n\ntype(2)\n\nint\n\n\n\ntype(3.1)\n\nfloat",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#variables-y-asignación",
    "href": "02_python.html#variables-y-asignación",
    "title": "Repaso de Python",
    "section": "",
    "text": "mensaje = 'Normalmente uno escribe: Hola, Mundo!'\n\n\nmensaje\n\n'Normalmente uno escribe: Hola, Mundo!'\n\n\n\nn = 17\n\n\nn\n\n17\n\n\n\ncasi_pi = 3.1416",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#expresiones",
    "href": "02_python.html#expresiones",
    "title": "Repaso de Python",
    "section": "",
    "text": "casi_pi + n\n\n20.1416\n\n\n\nprint(n)\n\n17",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#orden-de-operaciones",
    "href": "02_python.html#orden-de-operaciones",
    "title": "Repaso de Python",
    "section": "",
    "text": "En Python los operadores tienen jerarquía: - Exponenciación - Multiplicación y división - Suma y resta Primero se evalúan los de mayor jerarquía. Cuando hay dos iguales se evalúa de izquierda a derecha.\nCuando haya dudas, usar paréntesis, por ejemplo \\(2(3 - 1) = 4\\)\n\n2*(3 - 1)\n\n4\n\n\nLo siguiente es \\(1 + 2^3 = 9\\), muy distinto de \\((1 + 2)^3 = 27\\)\n\n1 + 2**3\n\n9\n\n\nEsto es \\(2\\times 3^2 = 18\\) muy distinto de \\((2\\times 3)^2 = 36\\)\n\n2*3**2\n\n18\n\n\n\n2*3 - 1\n\n5\n\n\n\n6 + 4/2\n\n8.0\n\n\n¡Cuidado! Si quiero escribir \\(4/(2\\times 2) = 1\\) no lo puedo hacer de esta manera.\n\n4/2*2\n\n4.0\n\n\n\n4/2/2\n\n1.0\n\n\n\n4/(2*2)\n\n1.0",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#comentarios",
    "href": "02_python.html#comentarios",
    "title": "Repaso de Python",
    "section": "",
    "text": "# Este código no hace nada, es puro comentario\n\n\n# Este código hace algo muy básico. Convierto mi pc en una calculadora cara\n2 + 3\n\n5",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#errores-y-excepciones",
    "href": "02_python.html#errores-y-excepciones",
    "title": "Repaso de Python",
    "section": "",
    "text": "Error de sintaxis\n\n2 +\n\n\n  Cell In[29], line 1\n    2 +\n       ^\nSyntaxError: invalid syntax\n\n\n\n\nOtros tipos de errores\n\nprint(2/0)\n\n\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nCell In[30], line 1\n----&gt; 1 print(2/0)\n\nZeroDivisionError: division by zero\n\n\n\n\nfor i in j:\n    print(i)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[31], line 1\n----&gt; 1 for i in j:\n      2     print(i)\n\nNameError: name 'j' is not defined\n\n\n\n\ndef mistake(n):\n    for i in range(n):\n        print(10/i)\n\n\nmistake(10)\n\n\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nCell In[33], line 1\n----&gt; 1 mistake(10)\n\nCell In[32], line 3, in mistake(n)\n      1 def mistake(n):\n      2     for i in range(n):\n----&gt; 3         print(10/i)\n\nZeroDivisionError: division by zero",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#obtener-y-modificar-elementos",
    "href": "02_python.html#obtener-y-modificar-elementos",
    "title": "Repaso de Python",
    "section": "Obtener y modificar elementos",
    "text": "Obtener y modificar elementos\n\nejemplo[0]\n\n'Pedro'\n\n\n\nejemplo[-1]\n\n['hola', 1.12]\n\n\nCuidado, lo siguiente muestra el tercer elemento, no el segundo\n\nejemplo[2]\n\n['hola', 1.12]\n\n\n\nejemplo[1] = 'adiós'\n\n\nejemplo\n\n['Pedro', 'adiós', ['hola', 1.12]]\n\n\n\nejemplo[3]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[72], line 1\n----&gt; 1 ejemplo[3]\n\nIndexError: list index out of range",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#atravesar-la-lista",
    "href": "02_python.html#atravesar-la-lista",
    "title": "Repaso de Python",
    "section": "Atravesar la lista",
    "text": "Atravesar la lista\n\nfor element in ejemplo:\n    print(element)\n\nPedro\nadiós\n['hola', 1.12]\n\n\n\nnumeros = [12,13,15,22,23]\n\n\nfor i in range(len(numeros)):\n    numeros[i] = numeros[i] + 1\n\n\nnumeros\n\n[13, 14, 16, 23, 24]",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#operaciones",
    "href": "02_python.html#operaciones",
    "title": "Repaso de Python",
    "section": "Operaciones",
    "text": "Operaciones\n\nnumeros2 = [1,2,3,4,5]\n\n\nnumeros3 = numeros + numeros2\n\n\nnumeros3\n\n[13, 14, 16, 23, 24, 1, 2, 3, 4, 5]\n\n\n\n[0,1]*4\n\n[0, 1, 0, 1, 0, 1, 0, 1]\n\n\n\nnumeros2.append(1)\n\n\nnumeros2\n\n[1, 2, 3, 4, 5, 1]\n\n\n\nnumeros2.extend([1,2])\n\n\nnumeros2\n\n[1, 2, 3, 4, 5, 1, 1, 2]\n\n\n\nsum(numeros2)\n\n19\n\n\n\ndel numeros2[1]\n\n\nnumeros2\n\n[1, 3, 4, 5, 1, 1, 2]",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#tajadas",
    "href": "02_python.html#tajadas",
    "title": "Repaso de Python",
    "section": "Tajadas",
    "text": "Tajadas\n\nnumeros3[1:2]\n\n[14]\n\n\n\nnumeros3[1:4]\n\n[14, 16, 23]\n\n\n\nnumeros3[1:]\n\n[14, 16, 23, 24, 1, 2, 3, 4, 5]\n\n\n\nnumeros3[:-2]\n\n[13, 14, 16, 23, 24, 1, 2, 3]\n\n\n\nnumeros3[:]\n\n[13, 14, 16, 23, 24, 1, 2, 3, 4, 5]",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#tarea-1.1",
    "href": "02_python.html#tarea-1.1",
    "title": "Repaso de Python",
    "section": "Tarea 1.1",
    "text": "Tarea 1.1\nUse Python como una calculadora para calcular cuál es la velocidad inicial de una bola que cae una distancia de \\(2\\) metros en \\(0.3\\) segundos.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#tarea-1.2",
    "href": "02_python.html#tarea-1.2",
    "title": "Repaso de Python",
    "section": "Tarea 1.2",
    "text": "Tarea 1.2\nEscriba un código que produzca el siguiente texto:\n1\n11  \n111  \n1111  \n11111  \n111111  \n1111111  \n11111111  \n111111111  \n1111111111  \n(El código no puede tener más de 4 líneas y un enunciado “print”). Puede usar el siguiente truco:\n\nprint(4*\"1\")\n\n1111",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#tarea-1.3",
    "href": "02_python.html#tarea-1.3",
    "title": "Repaso de Python",
    "section": "Tarea 1.3",
    "text": "Tarea 1.3\nEscriba un código que sea un loop infinito. En cada paso el código le pide al usuario que escriba algo y cuando el usuario escribe “salir” el código termina. Si el usuario escribe otra cosa el código no hace nada y sencillamente vuelve a pedirde al usuario que escriba algo. Para obtener la entrada del usuario use input('Escriba \"salir\" para salir: '). Para terminar el loop use break.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#tarea-1.4",
    "href": "02_python.html#tarea-1.4",
    "title": "Repaso de Python",
    "section": "Tarea 1.4",
    "text": "Tarea 1.4\nEscriba un código que haga la siguiente sumatoria:\n\\[\n\\sum_{n=0}^{100} \\sum_{m=0}^{n} \\left(0.3^n\\right)^m\n\\]",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "02_python.html#tarea-1.5",
    "href": "02_python.html#tarea-1.5",
    "title": "Repaso de Python",
    "section": "Tarea 1.5",
    "text": "Tarea 1.5\nEscriba un código que calcule el número de Euler con un error menor que 0.01 usando la expresión\n\\[\ne = \\sum_{n = 0}^\\infty \\frac{1}{n!}\\,.\n\\]\nPara calcular el error, puede comparar con la función math.exp(1). Para calcular el factorial de n, puede usar la función math.factorial(n). Para calcular el valor absoluto (puede ser necesario al calcular el error) use abs(x). Estas funciones estarán disponibles luego de ejecutar la siguiente línea.\n\nimport math",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de Python"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html",
    "href": "03_numpy_arrays.html",
    "title": "Repaso de numpy y otros",
    "section": "",
    "text": "Los arreglos son mucho más rápidos para cálculos numéricos ya que son un bloque continuo en memoria. Son similares a los arreglos en lenguajes como C.\n\nimport numpy as np\n\n\nmi_arreglo = np.array([1,2,3])\n\n\nmi_arreglo[1] = 5\n\n\nmi_arreglo\n\narray([1, 5, 3])\n\n\nLos arreglos sólo pueden contener datos de un tipo de datos. Cuando se mezclan tipos, Python hará lo mejor que pueda para convertirlos a un úunico tipo.\n\nnp.array([1,'hola'])\n\narray(['1', 'hola'], dtype='&lt;U21')\n\n\nPodemos hacer arreglos bidimensionales (matrices), tridimensionales, etc\n\nnp.array([[1,1],[1,1]])\n\narray([[1, 1],\n       [1, 1]])\n\n\nLos arreglos no pueden contener elementos de dimensiones diferentes\n\nnp.array([1,'hola',[2,'adios']])\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 np.array([1,'hola',[2,'adios']])\n\nValueError: setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (3,) + inhomogeneous part.\n\n\n\n\n\n\nnp.ones([3,4])\n\narray([[1., 1., 1., 1.],\n       [1., 1., 1., 1.],\n       [1., 1., 1., 1.]])\n\n\n\nnp.zeros((2,3,4))\n\narray([[[0., 0., 0., 0.],\n        [0., 0., 0., 0.],\n        [0., 0., 0., 0.]],\n\n       [[0., 0., 0., 0.],\n        [0., 0., 0., 0.],\n        [0., 0., 0., 0.]]])\n\n\n\nnp.full((3,2),3, dtype=np.float128)\n\narray([[3., 3.],\n       [3., 3.],\n       [3., 3.]], dtype=float128)\n\n\n\nnp.arange(10,25,5)\n\narray([10, 15, 20])\n\n\n\nmi_arreglo2 = np.linspace(0,2,9)\n\n\nmi_arreglo2\n\narray([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  ])\n\n\n\n\n\n\nmi_arreglo2.ndim\n\n1\n\n\n\nnp.full((3,2),3, dtype=np.float128).size\n\n6\n\n\n\nmi_arreglo2.data\n\n&lt;memory at 0x78b51e241180&gt;\n\n\n\nmi_arreglo2.shape\n\n(9,)\n\n\n\nmi_arreglo2.dtype\n\ndtype('float64')\n\n\n\nmi_arreglo2.nbytes\n\n72\n\n\n\nmi_arreglo2.astype(np.float16)\n\narray([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  ],\n      dtype=float16)\n\n\n\nmi_arreglo2.astype(np.float16).nbytes\n\n18\n\n\n\n\n\n\nmi_arreglo\n\narray([1, 5, 3])\n\n\n\nmi_arreglo3 =  mi_arreglo + 1\n\n\nmi_arreglo3\n\narray([2, 6, 4])\n\n\n\nmi_arreglo + mi_arreglo3\n\narray([ 3, 11,  7])\n\n\n\nmi_arreglo3/mi_arreglo\n\narray([2.        , 1.2       , 1.33333333])\n\n\n\nmi_arreglo3 == mi_arreglo\n\narray([False, False, False])\n\n\nSe pueden usar los operadores +, -, *, /, %, **, ==, !=, &gt;, &lt;, &gt;=, &lt;=\n\nmi_arreglo3.max()\n\nnp.int64(6)\n\n\n\nmi_arreglo3.min()\n\nnp.int64(2)\n\n\n\n\n\n\nmi_arreglo_2d = np.array([[1,2,3],[4,5,6],[7,8,9]])\n\n\nmi_arreglo_2d\n\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n\n\n\nmi_arreglo_2d[1:2]\n\narray([[4, 5, 6]])\n\n\n\nmi_arreglo_2d[1:]\n\narray([[4, 5, 6],\n       [7, 8, 9]])\n\n\n\nmi_arreglo_2d[1,1]\n\nnp.int64(5)\n\n\n¿Cuál es la diferencia? El siguiente código primero toma todas las filas desde la segunda (índice 1), luego toma la segunda de esas listas.\n\nmi_arreglo_2d[1:][1]\n\narray([7, 8, 9])\n\n\nPor otra parte, el siguiente código toma el primer elemento de cada una de esas listas.\n\nmi_arreglo_2d[1:,1]\n\narray([5, 8])\n\n\n\nmi_arreglo_2d[1:,:-1]\n\narray([[4, 5],\n       [7, 8]])\n\n\n\nmi_arreglo\n\narray([1, 5, 3])\n\n\n\nmi_arreglo[mi_arreglo&lt;=3]\n\narray([1, 3])\n\n\n\nmenor_que_3 = mi_arreglo &lt; 3\n\n\nmenor_que_3\n\narray([ True, False, False])\n\n\n\nmi_arreglo[menor_que_3]\n\narray([1])",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#llenar-arreglos-automáticamente",
    "href": "03_numpy_arrays.html#llenar-arreglos-automáticamente",
    "title": "Repaso de numpy y otros",
    "section": "",
    "text": "np.ones([3,4])\n\narray([[1., 1., 1., 1.],\n       [1., 1., 1., 1.],\n       [1., 1., 1., 1.]])\n\n\n\nnp.zeros((2,3,4))\n\narray([[[0., 0., 0., 0.],\n        [0., 0., 0., 0.],\n        [0., 0., 0., 0.]],\n\n       [[0., 0., 0., 0.],\n        [0., 0., 0., 0.],\n        [0., 0., 0., 0.]]])\n\n\n\nnp.full((3,2),3, dtype=np.float128)\n\narray([[3., 3.],\n       [3., 3.],\n       [3., 3.]], dtype=float128)\n\n\n\nnp.arange(10,25,5)\n\narray([10, 15, 20])\n\n\n\nmi_arreglo2 = np.linspace(0,2,9)\n\n\nmi_arreglo2\n\narray([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  ])",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#inspeccionar-arreglos",
    "href": "03_numpy_arrays.html#inspeccionar-arreglos",
    "title": "Repaso de numpy y otros",
    "section": "",
    "text": "mi_arreglo2.ndim\n\n1\n\n\n\nnp.full((3,2),3, dtype=np.float128).size\n\n6\n\n\n\nmi_arreglo2.data\n\n&lt;memory at 0x78b51e241180&gt;\n\n\n\nmi_arreglo2.shape\n\n(9,)\n\n\n\nmi_arreglo2.dtype\n\ndtype('float64')\n\n\n\nmi_arreglo2.nbytes\n\n72\n\n\n\nmi_arreglo2.astype(np.float16)\n\narray([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  ],\n      dtype=float16)\n\n\n\nmi_arreglo2.astype(np.float16).nbytes\n\n18",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#aritmética-de-arreglos",
    "href": "03_numpy_arrays.html#aritmética-de-arreglos",
    "title": "Repaso de numpy y otros",
    "section": "",
    "text": "mi_arreglo\n\narray([1, 5, 3])\n\n\n\nmi_arreglo3 =  mi_arreglo + 1\n\n\nmi_arreglo3\n\narray([2, 6, 4])\n\n\n\nmi_arreglo + mi_arreglo3\n\narray([ 3, 11,  7])\n\n\n\nmi_arreglo3/mi_arreglo\n\narray([2.        , 1.2       , 1.33333333])\n\n\n\nmi_arreglo3 == mi_arreglo\n\narray([False, False, False])\n\n\nSe pueden usar los operadores +, -, *, /, %, **, ==, !=, &gt;, &lt;, &gt;=, &lt;=\n\nmi_arreglo3.max()\n\nnp.int64(6)\n\n\n\nmi_arreglo3.min()\n\nnp.int64(2)",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#tajadas-de-arreglos",
    "href": "03_numpy_arrays.html#tajadas-de-arreglos",
    "title": "Repaso de numpy y otros",
    "section": "",
    "text": "mi_arreglo_2d = np.array([[1,2,3],[4,5,6],[7,8,9]])\n\n\nmi_arreglo_2d\n\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n\n\n\nmi_arreglo_2d[1:2]\n\narray([[4, 5, 6]])\n\n\n\nmi_arreglo_2d[1:]\n\narray([[4, 5, 6],\n       [7, 8, 9]])\n\n\n\nmi_arreglo_2d[1,1]\n\nnp.int64(5)\n\n\n¿Cuál es la diferencia? El siguiente código primero toma todas las filas desde la segunda (índice 1), luego toma la segunda de esas listas.\n\nmi_arreglo_2d[1:][1]\n\narray([7, 8, 9])\n\n\nPor otra parte, el siguiente código toma el primer elemento de cada una de esas listas.\n\nmi_arreglo_2d[1:,1]\n\narray([5, 8])\n\n\n\nmi_arreglo_2d[1:,:-1]\n\narray([[4, 5],\n       [7, 8]])\n\n\n\nmi_arreglo\n\narray([1, 5, 3])\n\n\n\nmi_arreglo[mi_arreglo&lt;=3]\n\narray([1, 3])\n\n\n\nmenor_que_3 = mi_arreglo &lt; 3\n\n\nmenor_que_3\n\narray([ True, False, False])\n\n\n\nmi_arreglo[menor_que_3]\n\narray([1])",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#preparar-los-datos",
    "href": "03_numpy_arrays.html#preparar-los-datos",
    "title": "Repaso de numpy y otros",
    "section": "Preparar los datos",
    "text": "Preparar los datos\nPara graficar necesitamos una tabla de datos. Estos pueden ser de dos tipos:\n\nResultados de la evaluación de una función (como en el ejemplo anterior).\nDatos de una simulación o una medición experimental.\n\n\n# Preparamos los datos\nx = np.linspace(-1,1,100)\ny1 = np.arccos(x)\ny2 = np.arcsin(x)\n\n\n# Producimos el gráfico \nplt.plot(x, y1, label=r'$\\cos^{-1}(x)$')\nplt.plot(x, y2, label=r'$\\sin^{-1}(x)$')\n\n# Para diferenciar los dos gráficos podemos incluir una leyenda\nplt.legend()\n\nplt.show()\n\n\n\n\n\n\n\n\nNormalmente los datos de un experimento o simulación están guardados en un archivo. Hablaremos de cómo manejar archivos más adelante. Por ahora ponemos a mano algunos datos (que son el resultado de una simulación de ciertas propiedades estadísticas de la distribución de materia a gran escala en el universo).\n\ndatos = np.array(\n    [[0.00314159, 3.0318397997408217, 0.4566634429053162], \n    [0.00628318, 2.7707221181056867, 0.17510327334847328], \n    [0.00942477, 2.6792094345075723, 0.14418474960362074], \n    [0.01256636, 2.8629530955402314, 0.0799879332308988], \n    [0.015707950000000002, 2.6228671669898738, 0.04669866360637852], \n    [0.01884954, 2.544881594794191, 0.032079885722964156], \n    [0.02199113, 2.457245781452802, 0.045660793878032256], \n    [0.02513272, 2.418177998205174, 0.041336657066345844], \n    [0.02827431, 2.358376185696977, 0.03448018004161942], \n    [0.031415900000000004, 2.346427014273152, 0.0331860259716874], \n    [0.03455749, 2.339197080901526, 0.02361983589273171], \n    [0.03769908, 2.2761885850394745, 0.026495927143311844], \n    [0.04084067, 2.2553242344026168, 0.021181457699213722], \n    [0.04398226, 2.218805385557498, 0.01764832127890884], \n    [0.04712385, 2.1968751769225405, 0.02084889785594682], \n    [0.05026544, 2.183116404353682, 0.0229514467313476], \n    [0.05340703, 2.149455000853029, 0.012785355627588396], \n    [0.05654862, 2.122002117746843, 0.017161461769528517], \n    [0.05969021, 2.0863880826499894, 0.013943154873837437]])\n\nEsto es el resultado de simular una cierta función \\(f(q)\\) donde \\(q\\) es la primera columna, \\(f\\) es la segunda columna y el error está en la tercera columna. Queremos solamente graficar f como función de q.\n\nq = datos[:,0]\nf = datos[:,1]\n\n\nplt.plot(q,f, label='$f(q)$')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nEstas son las notas (normalizadas entre 0 y 100) de un conjunto de estudiantes de licenciatura en física de una universidad norteamericana. El primer número es la nota en un curso de mecánica clásica, la segunda la nota en un curso de mecánica cuántica y la tercera es la nota de un curso de experimentación avanzada.\n\nnotas = np.array(\n[[100, 100, 93.0],\n [53.0, 60.0, 37.0],\n [42.0, 35.0, 89.0],\n [57.0, 54.0, 37.0],\n [77.0, 66.0, 53.0],\n [23.0, 26.0, 55.0],\n [97.0, 78.0, 68.0],\n [65.0, 45.0, 69.0],\n [74.0, 74.0, 84.0],\n [39.0, 44.0, 78.0],\n [95.0, 94.0, 25.0],\n [95.0, 74.0, 60.0],\n [77.0, 67.0, 17.0],\n [52.0, 47.0, 49.0],\n [66.0, 52.0, 27.0],\n [74.0, 63.0, 47.0],\n [79.0, 59.0, 13.0],\n [60.0, 40.0, 92.0],\n [80.0, 69.0, 36.0],\n [74.0, 44.0, 82.0],\n [100, 77.0, 7.0],\n [30.0, 23.0, 14.0],\n [96.0, 78.0, 57.0],\n [60.0, 81.0, 2.0],\n [57.0, 60.0, 29.0],\n [72.0, 88.0, 25.0],\n [44.0, 48.0, 58.0],\n [57.0, 53.0, 89.0],\n [58.0, 66.0, 31.0],\n [54.0, 48.0, 27.0],\n [58.0, 39.0, 86.0],\n [62.0, 55.0, 67.0],\n [54.0, 54.0, 66.0],\n [74.0, 70.0, 89.0],\n [60.0, 73.0, 39.0],\n [58.0, 74.0, 81.0],\n [50.0, 67.0, 52.0],\n [55.0, 50.0, 60.0],\n [91.0, 89.0, 70.0],\n [50.0, 55.0, 100],\n [47.0, 83.0, 51.0],\n [100, 100, 32.0],\n [53.0, 59.0, 72.0],\n [7.0, 39.0, 95.0],\n [73.0, 68.0, 76.0],\n [92.0, 100.0, 83.0],\n [81.0, 82.0, 66.0],\n [99.0, 88.0, 80.0],\n [79.0, 98.0, 48.0],\n [71.0, 45.0, 53.0]])",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#crear-el-gráfico",
    "href": "03_numpy_arrays.html#crear-el-gráfico",
    "title": "Repaso de numpy y otros",
    "section": "Crear el gráfico",
    "text": "Crear el gráfico\nLos ejemplos de arriba usan una versión simplificada (y mucho más limpia). Vamos a hacer unos ejemplos que usan toda la maquinaria de matplotlib, pero siempre es mejor usar la solución más sencilla.\n\n# Primero creamos una figura, es un objeto abstracto que puede contener varios gráficos\nfig = plt.figure()\n\n# Ahora creamos unos \"ejes\", que son la región donde el gráfico aparecerá\nax1 = fig.add_subplot(2,2,1) # número de filas, número de columnas, posición de este eje\nax2 = fig.add_subplot(2,2,2)\nax3 = fig.add_subplot(2,2,3)",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#graficar",
    "href": "03_numpy_arrays.html#graficar",
    "title": "Repaso de numpy y otros",
    "section": "Graficar",
    "text": "Graficar\n\nfig = plt.figure()\n\naxs1 = fig.add_subplot(2,2,1)\naxs2 = fig.add_subplot(2,2,2)\naxs3 = fig.add_subplot(2,2,3)\n\naxs1.scatter(notas[:,0], notas[:,1])\naxs2.scatter(notas[:,0], notas[:,2])\naxs3.scatter(notas[:,1], notas[:,2])\n\nfig.show()\n\n/tmp/ipykernel_155057/941235242.py:11: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n  fig.show()\n\n\n\n\n\n\n\n\n\n\n# Preparamos los datos\nx = np.linspace(0,2*np.pi,100)\ny = np.sin(x)\n\n# Graficamos los datos\nplt.fill(x, y)\n\n# Mostramos el gráfico\nplt.show()",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#parámetros-del-gráfico",
    "href": "03_numpy_arrays.html#parámetros-del-gráfico",
    "title": "Repaso de numpy y otros",
    "section": "Parámetros del gráfico",
    "text": "Parámetros del gráfico\nPodemos cambiar diferentes parámetros como el color, el tipo de línea o punto, etc.\n\nfig = plt.figure()\n\naxs1 = fig.add_subplot(2,2,1)\naxs2 = fig.add_subplot(2,2,2)\naxs3 = fig.add_subplot(2,2,3)\n\naxs1.scatter(notas[:,0], notas[:,1], color='yellowgreen', marker='^')\naxs2.scatter(notas[:,0], notas[:,2], color='teal', marker='o')\naxs3.scatter(notas[:,1], notas[:,2], color='darkslategray', marker='+')\n\nfig.suptitle('Correlación entre notas')\naxs1.set_title('Cuántica-Clásica')\naxs2.set_title('Cuántica-Experimental')\naxs3.set_title('Clásica-Experimental')\nfig.tight_layout(pad=2.0)\n\nfig.show()\n\n/tmp/ipykernel_155057/1727335637.py:17: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n  fig.show()\n\n\n\n\n\n\n\n\n\n\n# Preparamos los datos\nx = np.linspace(-1,1,100)\ny1 = np.arccos(x)\ny2 = np.arcsin(x)\ny3 = np.arctan(x)\n\nplt.plot(x, y1, label=r'$\\cos^{-1}(x)$', linestyle='--', color='turquoise', linewidth=2)\nplt.plot(x, y2, label=r'$\\sin^{-1}(x)$', linestyle='-', color='tan', linewidth=2)\nplt.plot(x, y3, label=r'$\\tan^{-1}(x)$', linestyle=':', color='cornflowerblue', linewidth=2.5)\nplt.xlabel('$x$')\nplt.ylabel('Función')\n\n# Para diferenciar los dos gráficos podemos incluir una leyenda\nplt.legend()\n\nplt.show()",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#guardar-el-gráfico",
    "href": "03_numpy_arrays.html#guardar-el-gráfico",
    "title": "Repaso de numpy y otros",
    "section": "Guardar el gráfico",
    "text": "Guardar el gráfico\n\nq = datos[:,0]\nf = datos[:,1]\ne = datos[:,2]\n\nplt.errorbar(q,f,e, ecolor='black', capsize=3)\nplt.xlabel('$q$')\nplt.ylabel('$f(q)$')\n\n## Importante! Poner antes de plt.show()\n#plt.savefig('datos.pdf')\n\nplt.show()",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#formato-para-archivos-de-texto",
    "href": "03_numpy_arrays.html#formato-para-archivos-de-texto",
    "title": "Repaso de numpy y otros",
    "section": "Formato para archivos de texto",
    "text": "Formato para archivos de texto\nNormalmente queremos guardar números bien formateados.\n\nimport numpy as np\n\n\nx = np.linspace(0,1,20)\ny = x**2\n\n\nwith open('copia.txt', 'w') as file:\n    for i in range(len(x)):\n        texto = f'{x[i]:020.3f}\\t{y[i]:.3e}\\n'\n        file.write(texto)\n\n\nwith open('copia.txt', 'r') as file:\n    x = []\n    y = []\n    for l in file:\n        xin, yin = l.split()\n        x.append(float(xin))\n        y.append(float(yin))\n        print(l, end='')\n\n0000000000000000.000    0.000e+00\n0000000000000000.053    2.770e-03\n0000000000000000.105    1.108e-02\n0000000000000000.158    2.493e-02\n0000000000000000.211    4.432e-02\n0000000000000000.263    6.925e-02\n0000000000000000.316    9.972e-02\n0000000000000000.368    1.357e-01\n0000000000000000.421    1.773e-01\n0000000000000000.474    2.244e-01\n0000000000000000.526    2.770e-01\n0000000000000000.579    3.352e-01\n0000000000000000.632    3.989e-01\n0000000000000000.684    4.681e-01\n0000000000000000.737    5.429e-01\n0000000000000000.789    6.233e-01\n0000000000000000.842    7.091e-01\n0000000000000000.895    8.006e-01\n0000000000000000.947    8.975e-01\n0000000000000001.000    1.000e+00\n\n\n\ny\n\n[0.0,\n 0.00277,\n 0.01108,\n 0.02493,\n 0.04432,\n 0.06925,\n 0.09972,\n 0.1357,\n 0.1773,\n 0.2244,\n 0.277,\n 0.3352,\n 0.3989,\n 0.4681,\n 0.5429,\n 0.6233,\n 0.7091,\n 0.8006,\n 0.8975,\n 1.0]",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#tarea-1.6",
    "href": "03_numpy_arrays.html#tarea-1.6",
    "title": "Repaso de numpy y otros",
    "section": "Tarea 1.6",
    "text": "Tarea 1.6\nUn colega le entrega a usted archivos de texto con los resultados de una simulación (simulacion.txt). Este archivo contiene tres columnas separadas por espacios tal que cada fila es un dato y las tres columnas son tres propiedades simuladas de ese dato.\nEscriba una función que lea ese archivo de texto y lo vuelva a guardar en un archivo simulacion.hd5 con tres datasets correspondientes a las tres propiedades de cada dato.\nComo usted quiere reutilizar esta función para cualquier otro archivo con tres columnas, la función debe tomar el nombre del archivo de texto y el nombre deseado para el nuevo archivo hd5 como argumentos.\nEl archivo simulacion.txt contiene por ejemplo lo siguiente:\n3.141590000000000094e-03 2.557680595776000416e+02 4.501400409434224770e+01 \n6.283180000000000189e-03 3.752818426478838205e+02 2.947770471609068110e+01 \n9.424770000000000716e-03 4.246697882492646841e+02 2.843524433400840579e+01 \n1.256636000000000038e-02 4.676325636948347437e+02 2.576223788106328882e+01 \n1.570795000000000177e-02 4.820912691815412359e+02 1.530261598082400276e+01 \n1.884954000000000143e-02 4.337667969674867550e+02 1.450243036000263963e+01 \n2.199113000000000109e-02 4.299064323187142804e+02 7.689521175184014012e+00 \n2.513272000000000075e-02 3.840742743415148084e+02 5.880658615460115257e+00 \n2.827431000000000041e-02 3.464876766126099596e+02 5.062040746246734280e+00",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#tarea-1.7",
    "href": "03_numpy_arrays.html#tarea-1.7",
    "title": "Repaso de numpy y otros",
    "section": "Tarea 1.7",
    "text": "Tarea 1.7\nSin usar ciclos for ni while, escriba un código que calcule la siguiente sumatoria\n\\[\n\\sum_{n = 1}^{100} e^n(n+1)\n\\]",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#tarea-1.8",
    "href": "03_numpy_arrays.html#tarea-1.8",
    "title": "Repaso de numpy y otros",
    "section": "Tarea 1.8",
    "text": "Tarea 1.8\nGrafique en una misma figura la siguiente función junto con su serie de Taylor alrededor de \\(x = 0\\) truncada al término número 10. ¿Hasta cuál valor de \\(x\\) parece ser una buena aproximación?\n\\[\nf(x) = x\\sin(x)\n\\]\nUse colores y estilos de línea diferentes para cada línea. Escoja un rango de valores de \\(x\\) que represente lo que quiera concluir sobre esta aproximación. Incluya una leyenda para facilitar la lectura del gráfico.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#tarea-1.9",
    "href": "03_numpy_arrays.html#tarea-1.9",
    "title": "Repaso de numpy y otros",
    "section": "Tarea 1.9",
    "text": "Tarea 1.9\nSuponga que usted es un ayudante de un laboratorio de física. En un experimento se pide medir la posición de una masa que cae en un plano inclinado a intervalos regulares en el tiempo. El equipo disponible puede medir las posiciones con una precisión de \\(4\\,\\text{mm}\\). Uno de los estudiantes usa los siguientes datos (en \\(\\text{cm}\\)):\n\ndatos = [0.9,  2. ,  3.6,  5.6,  8. , 10.9, 14.2, 18.]\n\nGrafique estos datos con sus barras de error. Explique por qué el estudiante merece una nota de 1.0. Compare con los siguientes datos obtenidos por un estudiante que merece 7.0.\n\ndatos_7 = [0.3,  1.7,  4.1,  5.7,  8.5, 10.7, 13.6, 17.2]",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "03_numpy_arrays.html#tarea-1.10",
    "href": "03_numpy_arrays.html#tarea-1.10",
    "title": "Repaso de numpy y otros",
    "section": "Tarea 1.10",
    "text": "Tarea 1.10\nUn colega le pasa a usted un archivo .hd5 que contiene tres “datasets” ‘x’, ‘y’, ‘e’. Todos los datasets tienen la misma longitud y el i-ésimo elemento de cada dataset corresponde a una propiedad diferente del i-ésimo dato.\nEscriba una función que grafique esos resultados donde ‘x’ es el eje horizontal, ‘y’ el eje vertical y ‘e’ son las barras de error de ‘y’.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Repaso de numpy, matplotlib, archivos"
    ]
  },
  {
    "objectID": "plan.html",
    "href": "plan.html",
    "title": "Métodos Numéricos y Probabilidades",
    "section": "",
    "text": "Las (los) físicas (os) siempre han llevado la punta de lanza del desarrollo tecnológico. Desde la revolución industrial hasta el desarrollo de la computación cuántica, los (las) físicos (as) han tenido un manejo profundo de la tecnología que les permite hacer nuevos descubrimientos o inventos. Esto es aún más cierto en el siglo XXI, en el cual la mayoría de las (los) licenciadas (os) en física de los países de alto desarrollo tecnológico trabajan en el sector privado creando y mejorando las herramientas informáticas, financieras y estadísticas que usamos todos los días. Esto se debe a que a lo largo de sus carreras adquieren un conocimiento íntimo de la tecnología de punta al intentar aplicarla a problemas científicos abiertos.\nSon muy pocos los problemas que admiten una solución sencilla de lápiz y papel. Para la mayoría de nuevos desarrollos es necesario usar el computador. Esto es verdad tanto para analizar los datos obtenidos en los experimentos, como para resolver las ecuaciones diferenciales que aparecen en la física teórica. Incluso quienes hacen un trabajo puramente analítico se apoyan en herramientas computacionales para los cálculos que son cada vez más complejos.\nEn este curso aprenderemos a usar las herramientas numéricas disponibles para atacar problemas físicos y al hacerlo aprenderemos a usar plataformas, paquetes y lenguajes de programación modernos.\n\n\n\n\nR. L. Burden, D. J. Faires, A. M. Burden, “Numerical Analysis”, 10ma edición, Cengage Learning, 2016 (NA)\nT. A. Driscoll, R. J. Braun, “Funamentals of Numerical Computation”, 2da edición, SIAM, 2022 (FNC)\nB. R. Martin, “Statistics for Physical Sciences”. Elsevier, 2012 (S)\nA. B. Downey, “Think Python,” 2da edición, O’Reilly, 2015. (TP)\n\n\n\n\nSe indican las fechas y temas de cada clase, junto con las secciones de los libros a las que corresponden.\n1- Introducción\n\n¿Cómo funciona una CPU?, 7 de agosto.\nRepaso de Python, 12 de agosto.\nNumpy y arrays, 14 de agosto.\nRepresentación binaria de números decimales, número de condicionamiento 19 de agosto\nAlgoritmos y estabilidad 21 de agosto\n\n2- Probabilidades\n\nPropiedades básicas de la probabilidad, 26 de agosto\nDistribuciones de probabilidad, 28 de agosto\nVarias variables aleatorias, 2 de septiembre\nSuma de muchas variables aleatorias y teorema central del límite, 4 de septiembre\nInformación y entropía, 9 de septiembre\n\nPrueba: 23 de septiembre\n3- Cálculo numérico\n\nSolución de sistemas de ecuaciones lineales: Inversión de matrices, 11 de septiembre\nBúsqueda de raíces: Métodos de bisección y Newton, 25 de septiembre\nInterpolación, 30 de septiembre\nDerivadas numéricas y autodiferenciación, 2 de octubre\nIntegración numérica simple y adaptativa, 7 de octubre\nIntegración numérica por método de Gauss, 9 de octubre\n\nPrueba: 16 de octubre\n4- Solución numérica de ecuaciones diferenciales ordinarias\n\nMétodos de Euler y Taylor, 14 de octubre\nMétodo de Runge Kutta, 21 de octubre\nMétodo de Runge Kutta adaptativo, 23 de octubre\nMétodos de múltiples pasos y método de Adams, 4 de noviembre\nSistemas de ecuaciones diferenciales y ecuaciones de alto orden, 6 de noviembre\n\nPrueba: 13 de noviembre\n5- Optimización y otros algoritmos importantes\n\nAjuste de curvas y bondad de ajuste, 11 de noviembre\nOptimización por descenso de gradiente, 18 de noviembre\nIntroducción a las redes neuronales, 20 de noviembre\nMétodos de Monte Carlo y/o transformada rápida de Fourier, 25 de noviembre\n\nRecuperativa: 27 de noviembre Examen: Definido por Instituto\n\n\n\nLa evaluación se hará por tareas y pruebas.\nAl final de cada clase habrán 5 tareas para un total de 10 tareas cada dos clases. De estas 10 tareas se le asignará de forma aleatoria una tarea a cada estudiante. De esta manera el estudiante deberá entregar aproximadamente 11 tareas a lo largo del curso. El 50% de la nota final es el promedio de las notas de las tareas.\nLas tareas se entregan dos clases después de haber sido asignadas.\nSe evaluará lo siguiente:\nEl código funciona (4 puntos): Si el código pedido hace lo que deberíacumplir sin errores en ningún caso, la estudiante obtendrá los 4 puntos. Si existen casos especiales en los cuales el código no funciona, pero funciona en la mayoría de los casos, la estudiante obtendrá 3 puntos. Si el código no funciona pero el error es menor (algún detalle de sintaxis, alguna variable mal nombrada, alguna excepción de Python difícil de prever), el estudiante obtendrá 2 puntos. Si el código no funciona el estudiante obtendrá 1 punto. Si no entrega la tarea el estudiante obtendrá 0 puntos.\nEl código es legible (+2 puntos): Si el código está comentado en cada paso el estudiante obtendrá +1 punto. Si el código es fácil de entender, está bien organizado, las variables tienen nombres que corresponden a lo que representan la estudiante obtendrá +1 punto.\nLa nota de la tarea = # de puntos + 1.\nLa otra mitad de la nota será el promedio de tres pruebas realizadas a lo largo del semestre. Las pruebas consisten en ejercicios sencillos basados en lo visto en clase y en las tareas.\nLas siguientes son las fechas de las pruebas:\nPrueba: 10 de septiembre Prueba: 5 de noviembre Prueba: 25 de noviembre Recuperativa: 26 de noviembre Examen: 10 de diciembre\n\n\n\nLos estudiantes no están obligados a ir a las ayudantías, pero obviamente quien asista estará mejor preparado para las pruebas y los exámenes porque sabrá cuáles son los problemas que entran. Las tareas se entregarán en formato electrónico por medio de la plataforma GitHub. Se usa esta en vez del Aula Virtual dado su uso extenso en el mundo profesional.\nHágale preguntas al profesor a la dirección jorge.norena@pucv.cl, o en el horario de atención. Hacer preguntas ayuda a aprender y hace más ameno el trabajo del profesor. La clase empieza puntual si hay al menos un estudiante presente, por respeto a los que llegan a tiempo.\n\n\n\nPOR FAVOR HAGAN PREGUNTAS DURANTE LA CLASE, LAS AYUDANTÍAS, POR CORREO ELECTRÓNICO, EN LOS HORARIOS DE ATENCIÓN Y POR CUALQUIER OTRO MEDIO QUE PUEDA.\nSi quiere conversar hágalo por chat en su teléfono para que el ruido no distraiga a los demás. Use el teléfono para tomarle fotos a la pizarra cuando quiera recordar algo.\n\n\n\nPuede en cualquier momento hacer preguntas por correo electrónico.\nCorreo electrónico profesor: jorge.norena@pucv.cl Correo electrónico de la ayudante:\nTambién puede pasar por la oficina del profesor en cualquier momento.\nEl horario de atención reservado es una hora después de cada clase."
  },
  {
    "objectID": "plan.html#motivación",
    "href": "plan.html#motivación",
    "title": "Métodos Numéricos y Probabilidades",
    "section": "",
    "text": "Las (los) físicas (os) siempre han llevado la punta de lanza del desarrollo tecnológico. Desde la revolución industrial hasta el desarrollo de la computación cuántica, los (las) físicos (as) han tenido un manejo profundo de la tecnología que les permite hacer nuevos descubrimientos o inventos. Esto es aún más cierto en el siglo XXI, en el cual la mayoría de las (los) licenciadas (os) en física de los países de alto desarrollo tecnológico trabajan en el sector privado creando y mejorando las herramientas informáticas, financieras y estadísticas que usamos todos los días. Esto se debe a que a lo largo de sus carreras adquieren un conocimiento íntimo de la tecnología de punta al intentar aplicarla a problemas científicos abiertos.\nSon muy pocos los problemas que admiten una solución sencilla de lápiz y papel. Para la mayoría de nuevos desarrollos es necesario usar el computador. Esto es verdad tanto para analizar los datos obtenidos en los experimentos, como para resolver las ecuaciones diferenciales que aparecen en la física teórica. Incluso quienes hacen un trabajo puramente analítico se apoyan en herramientas computacionales para los cálculos que son cada vez más complejos.\nEn este curso aprenderemos a usar las herramientas numéricas disponibles para atacar problemas físicos y al hacerlo aprenderemos a usar plataformas, paquetes y lenguajes de programación modernos."
  },
  {
    "objectID": "plan.html#lecturas-sugeridas",
    "href": "plan.html#lecturas-sugeridas",
    "title": "Métodos Numéricos y Probabilidades",
    "section": "",
    "text": "R. L. Burden, D. J. Faires, A. M. Burden, “Numerical Analysis”, 10ma edición, Cengage Learning, 2016 (NA)\nT. A. Driscoll, R. J. Braun, “Funamentals of Numerical Computation”, 2da edición, SIAM, 2022 (FNC)\nB. R. Martin, “Statistics for Physical Sciences”. Elsevier, 2012 (S)\nA. B. Downey, “Think Python,” 2da edición, O’Reilly, 2015. (TP)"
  },
  {
    "objectID": "plan.html#programa",
    "href": "plan.html#programa",
    "title": "Métodos Numéricos y Probabilidades",
    "section": "",
    "text": "Se indican las fechas y temas de cada clase, junto con las secciones de los libros a las que corresponden.\n1- Introducción\n\n¿Cómo funciona una CPU?, 7 de agosto.\nRepaso de Python, 12 de agosto.\nNumpy y arrays, 14 de agosto.\nRepresentación binaria de números decimales, número de condicionamiento 19 de agosto\nAlgoritmos y estabilidad 21 de agosto\n\n2- Probabilidades\n\nPropiedades básicas de la probabilidad, 26 de agosto\nDistribuciones de probabilidad, 28 de agosto\nVarias variables aleatorias, 2 de septiembre\nSuma de muchas variables aleatorias y teorema central del límite, 4 de septiembre\nInformación y entropía, 9 de septiembre\n\nPrueba: 23 de septiembre\n3- Cálculo numérico\n\nSolución de sistemas de ecuaciones lineales: Inversión de matrices, 11 de septiembre\nBúsqueda de raíces: Métodos de bisección y Newton, 25 de septiembre\nInterpolación, 30 de septiembre\nDerivadas numéricas y autodiferenciación, 2 de octubre\nIntegración numérica simple y adaptativa, 7 de octubre\nIntegración numérica por método de Gauss, 9 de octubre\n\nPrueba: 16 de octubre\n4- Solución numérica de ecuaciones diferenciales ordinarias\n\nMétodos de Euler y Taylor, 14 de octubre\nMétodo de Runge Kutta, 21 de octubre\nMétodo de Runge Kutta adaptativo, 23 de octubre\nMétodos de múltiples pasos y método de Adams, 4 de noviembre\nSistemas de ecuaciones diferenciales y ecuaciones de alto orden, 6 de noviembre\n\nPrueba: 13 de noviembre\n5- Optimización y otros algoritmos importantes\n\nAjuste de curvas y bondad de ajuste, 11 de noviembre\nOptimización por descenso de gradiente, 18 de noviembre\nIntroducción a las redes neuronales, 20 de noviembre\nMétodos de Monte Carlo y/o transformada rápida de Fourier, 25 de noviembre\n\nRecuperativa: 27 de noviembre Examen: Definido por Instituto"
  },
  {
    "objectID": "plan.html#evaluación",
    "href": "plan.html#evaluación",
    "title": "Métodos Numéricos y Probabilidades",
    "section": "",
    "text": "La evaluación se hará por tareas y pruebas.\nAl final de cada clase habrán 5 tareas para un total de 10 tareas cada dos clases. De estas 10 tareas se le asignará de forma aleatoria una tarea a cada estudiante. De esta manera el estudiante deberá entregar aproximadamente 11 tareas a lo largo del curso. El 50% de la nota final es el promedio de las notas de las tareas.\nLas tareas se entregan dos clases después de haber sido asignadas.\nSe evaluará lo siguiente:\nEl código funciona (4 puntos): Si el código pedido hace lo que deberíacumplir sin errores en ningún caso, la estudiante obtendrá los 4 puntos. Si existen casos especiales en los cuales el código no funciona, pero funciona en la mayoría de los casos, la estudiante obtendrá 3 puntos. Si el código no funciona pero el error es menor (algún detalle de sintaxis, alguna variable mal nombrada, alguna excepción de Python difícil de prever), el estudiante obtendrá 2 puntos. Si el código no funciona el estudiante obtendrá 1 punto. Si no entrega la tarea el estudiante obtendrá 0 puntos.\nEl código es legible (+2 puntos): Si el código está comentado en cada paso el estudiante obtendrá +1 punto. Si el código es fácil de entender, está bien organizado, las variables tienen nombres que corresponden a lo que representan la estudiante obtendrá +1 punto.\nLa nota de la tarea = # de puntos + 1.\nLa otra mitad de la nota será el promedio de tres pruebas realizadas a lo largo del semestre. Las pruebas consisten en ejercicios sencillos basados en lo visto en clase y en las tareas.\nLas siguientes son las fechas de las pruebas:\nPrueba: 10 de septiembre Prueba: 5 de noviembre Prueba: 25 de noviembre Recuperativa: 26 de noviembre Examen: 10 de diciembre"
  },
  {
    "objectID": "plan.html#normas",
    "href": "plan.html#normas",
    "title": "Métodos Numéricos y Probabilidades",
    "section": "",
    "text": "Los estudiantes no están obligados a ir a las ayudantías, pero obviamente quien asista estará mejor preparado para las pruebas y los exámenes porque sabrá cuáles son los problemas que entran. Las tareas se entregarán en formato electrónico por medio de la plataforma GitHub. Se usa esta en vez del Aula Virtual dado su uso extenso en el mundo profesional.\nHágale preguntas al profesor a la dirección jorge.norena@pucv.cl, o en el horario de atención. Hacer preguntas ayuda a aprender y hace más ameno el trabajo del profesor. La clase empieza puntual si hay al menos un estudiante presente, por respeto a los que llegan a tiempo."
  },
  {
    "objectID": "plan.html#recomendaciones",
    "href": "plan.html#recomendaciones",
    "title": "Métodos Numéricos y Probabilidades",
    "section": "",
    "text": "POR FAVOR HAGAN PREGUNTAS DURANTE LA CLASE, LAS AYUDANTÍAS, POR CORREO ELECTRÓNICO, EN LOS HORARIOS DE ATENCIÓN Y POR CUALQUIER OTRO MEDIO QUE PUEDA.\nSi quiere conversar hágalo por chat en su teléfono para que el ruido no distraiga a los demás. Use el teléfono para tomarle fotos a la pizarra cuando quiera recordar algo."
  },
  {
    "objectID": "plan.html#horarios-de-atención-y-contacto",
    "href": "plan.html#horarios-de-atención-y-contacto",
    "title": "Métodos Numéricos y Probabilidades",
    "section": "",
    "text": "Puede en cualquier momento hacer preguntas por correo electrónico.\nCorreo electrónico profesor: jorge.norena@pucv.cl Correo electrónico de la ayudante:\nTambién puede pasar por la oficina del profesor en cualquier momento.\nEl horario de atención reservado es una hora después de cada clase."
  },
  {
    "objectID": "04_numeros_y_condicionamiento.html",
    "href": "04_numeros_y_condicionamiento.html",
    "title": "Clase 4: Representación de números y número de condicionamiento",
    "section": "",
    "text": "El computador representa los números usando un sistema binario. Es decir, una lista de 1s y 0s. Las CPUs modernas usan 64 bits, cada uno de los cuales puede ser 0 o 1. Como esto es un número finito de información, la precisión del computador para guardar un número no es infinita y esto puede inducir errores.\nPara entender el problema, hagamos un ejemplo con 16 bits.\n\nimport numpy as np\n\n\npi = np.float16(np.pi)\ndos = np.float16(2)\ncien = np.float16(100)\ncien*np.sin(dos*pi)\n\nnp.float16(-0.1935)\n\n\n\n\nPara guardar un número real en la memoria de un pc se usa la siguiente representación\n\\[\n(-1)^s 2^{n} (1 + f)\\,,\n\\]\ndonde \\(s\\) es el signo, \\(n\\) es el exponente, y la mantisa \\(f\\) es \\(f = \\sum_{i=1}^d b_i 2^{-i}\\).\nEl exponente normalmente se define como \\(n = c - 2^{k-1} + 1\\), donde \\(k\\) es el número de bits en la representación.\n\n\n\nPara ilustrar el tipo de dificultades que esto introduce es engorroso trabajar con números tan grandes. Por eso trabajamos con números de 16 bits (como si estuviéramos en los años 90). Un número de este estilo es\n1 11010 1111000100\nEl primer dígito es \\(s\\), los siguientes cinco forman \\(c\\) y los siguientes diez forman \\(f\\) de manera análoga a la de antes. En nuestro ejemplo tenemos\n\\[\nf = \\left(\\frac{1}{2}\\right)^1 + \\left(\\frac{1}{2}\\right)^2 + \\left(\\frac{1}{2}\\right)^3 + \\left(\\frac{1}{2}\\right)^4 + \\left(\\frac{1}{2}\\right)^8 = 0.94140625\n\\]\n\\[\nc = 2^4 + 2^3 + 2^1 = 26\n\\]\nEl número total está dado por \\[(-1)^s 2^{c - 15} (1 + f)\\]\nEl número de nuestro ejemplo es\n\\[\n(-1)\\times 2^{26 - 15} 1.94140625 = -3976\n\\]\n\nNúmero más grande de 16 bits\n\n0 11110 1111111111\n\nf = sum((1/2.)**(np.arange(1,11)))\nf\n\nnp.float64(0.9990234375)\n\n\n\nc = sum(2**(np.arange(1,5)))\nc\n\nnp.int64(30)\n\n\n\n2**(c - 15)*(1 + f)\n\nnp.float64(65504.0)\n\n\n\nNúmero más pequeño de 16 bits\n\n1 11110 1111111111\n\n-2**(c-15)*(1 + f)\n\nnp.float64(-65504.0)\n\n\n\nNúmero más cercano a cero de 16 bits\n\n0 00000 0000000001\n\n2**(1-15)*((1/2)**10)\n\n5.960464477539063e-08\n\n\n\nCifras decimales de precisión de 16 bits\n\n0 00000 0000000001\n\n(1/2)**(10)\n\n0.0009765625\n\n\nAlgo análogo ocurre para números representados con 64 bits sólo que ahora tenemos más bits disponibles para el exponente y la mantisa, lo que nos da más precisión. En ese caso tenemos 15 cifras de precisión. Hoy en día se usan también números de 32 bits para algunos cálculos, estos tienen aproximadamente 7 cifras de precisión.\nSi el lector está interesado, puede consultar cómo el uso de números aún más pequeños ha resurgido en el contexto de modelos de inteligencia artificial. Esto acelera los modelos. En esos casos se usa una mantisa más pequeña porque lo importante es el orden de magnitud del número.\n\n\n\nPara explorar este problema, ignoremos por ahora el sistema binario y veamos lo que ocurre en el sistema decimal.\n\nnp.pi\n\n3.141592653589793\n\n\nEn este caso, si queremos representar el número \\(\\pi\\) con una cierta cantidad \\(n\\) de cifras significativas podemos hacer dos cosas:\n\nTruncar: Ignoramos las cifras adicionales, más allá de la \\(n\\)-ésima cifra.\n\n\npi_truncado = 3.1415\n\n\nRedondear: Si la cifra \\(n + 1\\) es menor a 5 truncamos, pero si la cifra \\(n + 1\\) es mayor o igual que 5\n\n\npi_redondeado = 3.1416\n\nAl truncar o redondear cometemos un error. Podemos cuantificar el error de varias maneras:\n\nError real: estimación - valor verdadero\n\n\npi_truncado - np.pi\n\n-9.265358979293481e-05\n\n\n\npi_redondeado - np.pi\n\n7.346410206832132e-06\n\n\n\nError absoluto: |estimación - valor verdadero|\n\n\nnp.abs(pi_truncado - np.pi)\n\nnp.float64(9.265358979293481e-05)\n\n\n\nnp.abs(pi_redondeado - np.pi)\n\nnp.float64(7.346410206832132e-06)\n\n\n\nError relativo: |estimación - valor verdadero|/|valor verdadero|\n\n\nnp.abs(pi_truncado - np.pi)/np.abs(np.pi)\n\nnp.float64(2.9492553621508708e-05)\n\n\n\nnp.abs(pi_redondeado - np.pi)/np.abs(np.pi)\n\nnp.float64(2.3384349967961744e-06)\n\n\n\n\n\nEl número más cercano a \\(1\\) por la derecha en \\(16\\) bits es\n0 00000 0000000001\nRestándole \\(1\\), este se llama el \\(\\epsilon\\) de máquina. En el caso de 16 bits es burdamente \\(10^{-3}\\). En el caso de 64 bits es \\(\\sim 10^{-16}\\) y en el caso de 32 bits es \\(\\sim 10^{-8}\\). Esta es la máxima precisión que podemos alcanzar al operar con números representados de esta forma.\n\nnp.finfo(np.float32).eps\n\nnp.float32(1.1920929e-07)\n\n\n\nnp.finfo(np.float64).eps\n\nnp.float64(2.220446049250313e-16)\n\n\nCuidado, el verdadero error cometido es el \\(\\epsilon_{maq}\\) multiplicado por el exponente, tal que el error al usar números en \\([1/2, 1)\\) es en realidad \\(\\epsilon_{maq}/2\\) por ejemplo.\n\neps = np.finfo(float).eps\nx = eps/2\n(1.0 + x) - 1.0\n\nnp.float64(0.0)\n\n\n\n1.0 + (x - 1.0)\n\nnp.float64(1.1102230246251565e-16)\n\n\nSegún el estándar IEEE 754, los resultados de las sumas, restas, multiplicaciones y divisiones de números de punto flotante en el computador deben dar un resultado igual a hacer el cálculo con números reales y luego redondear a la precisión de la representación.\n\n\n\n\n\n\nAdvertencia\n\n\n\nComo vimos con el ejemplo de arriba, todo esto quiere decir que dos resultados matemáticamente equivalentes no dan necesariamente el mismo resultado si se usa aritmética de punto flotante.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Representación de números y condicionamiento"
    ]
  },
  {
    "objectID": "04_numeros_y_condicionamiento.html#representación-binaria-de-números-decimales",
    "href": "04_numeros_y_condicionamiento.html#representación-binaria-de-números-decimales",
    "title": "Clase 4: Representación de números y número de condicionamiento",
    "section": "",
    "text": "Para guardar un número real en la memoria de un pc se usa la siguiente representación\n\\[\n(-1)^s 2^{n} (1 + f)\\,,\n\\]\ndonde \\(s\\) es el signo, \\(n\\) es el exponente, y la mantisa \\(f\\) es \\(f = \\sum_{i=1}^d b_i 2^{-i}\\).\nEl exponente normalmente se define como \\(n = c - 2^{k-1} + 1\\), donde \\(k\\) es el número de bits en la representación.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Representación de números y condicionamiento"
    ]
  },
  {
    "objectID": "04_numeros_y_condicionamiento.html#números-de-16-bits",
    "href": "04_numeros_y_condicionamiento.html#números-de-16-bits",
    "title": "Clase 4: Representación de números y número de condicionamiento",
    "section": "",
    "text": "Para ilustrar el tipo de dificultades que esto introduce es engorroso trabajar con números tan grandes. Por eso trabajamos con números de 16 bits (como si estuviéramos en los años 90). Un número de este estilo es\n1 11010 1111000100\nEl primer dígito es \\(s\\), los siguientes cinco forman \\(c\\) y los siguientes diez forman \\(f\\) de manera análoga a la de antes. En nuestro ejemplo tenemos\n\\[\nf = \\left(\\frac{1}{2}\\right)^1 + \\left(\\frac{1}{2}\\right)^2 + \\left(\\frac{1}{2}\\right)^3 + \\left(\\frac{1}{2}\\right)^4 + \\left(\\frac{1}{2}\\right)^8 = 0.94140625\n\\]\n\\[\nc = 2^4 + 2^3 + 2^1 = 26\n\\]\nEl número total está dado por \\[(-1)^s 2^{c - 15} (1 + f)\\]\nEl número de nuestro ejemplo es\n\\[\n(-1)\\times 2^{26 - 15} 1.94140625 = -3976\n\\]\n\nNúmero más grande de 16 bits\n\n0 11110 1111111111\n\nf = sum((1/2.)**(np.arange(1,11)))\nf\n\nnp.float64(0.9990234375)\n\n\n\nc = sum(2**(np.arange(1,5)))\nc\n\nnp.int64(30)\n\n\n\n2**(c - 15)*(1 + f)\n\nnp.float64(65504.0)\n\n\n\nNúmero más pequeño de 16 bits\n\n1 11110 1111111111\n\n-2**(c-15)*(1 + f)\n\nnp.float64(-65504.0)\n\n\n\nNúmero más cercano a cero de 16 bits\n\n0 00000 0000000001\n\n2**(1-15)*((1/2)**10)\n\n5.960464477539063e-08\n\n\n\nCifras decimales de precisión de 16 bits\n\n0 00000 0000000001\n\n(1/2)**(10)\n\n0.0009765625\n\n\nAlgo análogo ocurre para números representados con 64 bits sólo que ahora tenemos más bits disponibles para el exponente y la mantisa, lo que nos da más precisión. En ese caso tenemos 15 cifras de precisión. Hoy en día se usan también números de 32 bits para algunos cálculos, estos tienen aproximadamente 7 cifras de precisión.\nSi el lector está interesado, puede consultar cómo el uso de números aún más pequeños ha resurgido en el contexto de modelos de inteligencia artificial. Esto acelera los modelos. En esos casos se usa una mantisa más pequeña porque lo importante es el orden de magnitud del número.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Representación de números y condicionamiento"
    ]
  },
  {
    "objectID": "04_numeros_y_condicionamiento.html#redondeo-truncación-error-absoluto-y-relativo",
    "href": "04_numeros_y_condicionamiento.html#redondeo-truncación-error-absoluto-y-relativo",
    "title": "Clase 4: Representación de números y número de condicionamiento",
    "section": "",
    "text": "Para explorar este problema, ignoremos por ahora el sistema binario y veamos lo que ocurre en el sistema decimal.\n\nnp.pi\n\n3.141592653589793\n\n\nEn este caso, si queremos representar el número \\(\\pi\\) con una cierta cantidad \\(n\\) de cifras significativas podemos hacer dos cosas:\n\nTruncar: Ignoramos las cifras adicionales, más allá de la \\(n\\)-ésima cifra.\n\n\npi_truncado = 3.1415\n\n\nRedondear: Si la cifra \\(n + 1\\) es menor a 5 truncamos, pero si la cifra \\(n + 1\\) es mayor o igual que 5\n\n\npi_redondeado = 3.1416\n\nAl truncar o redondear cometemos un error. Podemos cuantificar el error de varias maneras:\n\nError real: estimación - valor verdadero\n\n\npi_truncado - np.pi\n\n-9.265358979293481e-05\n\n\n\npi_redondeado - np.pi\n\n7.346410206832132e-06\n\n\n\nError absoluto: |estimación - valor verdadero|\n\n\nnp.abs(pi_truncado - np.pi)\n\nnp.float64(9.265358979293481e-05)\n\n\n\nnp.abs(pi_redondeado - np.pi)\n\nnp.float64(7.346410206832132e-06)\n\n\n\nError relativo: |estimación - valor verdadero|/|valor verdadero|\n\n\nnp.abs(pi_truncado - np.pi)/np.abs(np.pi)\n\nnp.float64(2.9492553621508708e-05)\n\n\n\nnp.abs(pi_redondeado - np.pi)/np.abs(np.pi)\n\nnp.float64(2.3384349967961744e-06)",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Representación de números y condicionamiento"
    ]
  },
  {
    "objectID": "04_numeros_y_condicionamiento.html#aritmética-de-dígitos-finitos",
    "href": "04_numeros_y_condicionamiento.html#aritmética-de-dígitos-finitos",
    "title": "Clase 4: Representación de números y número de condicionamiento",
    "section": "",
    "text": "El número más cercano a \\(1\\) por la derecha en \\(16\\) bits es\n0 00000 0000000001\nRestándole \\(1\\), este se llama el \\(\\epsilon\\) de máquina. En el caso de 16 bits es burdamente \\(10^{-3}\\). En el caso de 64 bits es \\(\\sim 10^{-16}\\) y en el caso de 32 bits es \\(\\sim 10^{-8}\\). Esta es la máxima precisión que podemos alcanzar al operar con números representados de esta forma.\n\nnp.finfo(np.float32).eps\n\nnp.float32(1.1920929e-07)\n\n\n\nnp.finfo(np.float64).eps\n\nnp.float64(2.220446049250313e-16)\n\n\nCuidado, el verdadero error cometido es el \\(\\epsilon_{maq}\\) multiplicado por el exponente, tal que el error al usar números en \\([1/2, 1)\\) es en realidad \\(\\epsilon_{maq}/2\\) por ejemplo.\n\neps = np.finfo(float).eps\nx = eps/2\n(1.0 + x) - 1.0\n\nnp.float64(0.0)\n\n\n\n1.0 + (x - 1.0)\n\nnp.float64(1.1102230246251565e-16)\n\n\nSegún el estándar IEEE 754, los resultados de las sumas, restas, multiplicaciones y divisiones de números de punto flotante en el computador deben dar un resultado igual a hacer el cálculo con números reales y luego redondear a la precisión de la representación.\n\n\n\n\n\n\nAdvertencia\n\n\n\nComo vimos con el ejemplo de arriba, todo esto quiere decir que dos resultados matemáticamente equivalentes no dan necesariamente el mismo resultado si se usa aritmética de punto flotante.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Representación de números y condicionamiento"
    ]
  },
  {
    "objectID": "04_numeros_y_condicionamiento.html#tarea-2.1",
    "href": "04_numeros_y_condicionamiento.html#tarea-2.1",
    "title": "Clase 4: Representación de números y número de condicionamiento",
    "section": "Tarea 2.1",
    "text": "Tarea 2.1\nSuponga que usamos 64 bits para representar un número de punto flotante. Queremos resolver un problema numérico con número de condicionamiento \\(\\kappa \\sim 10^6\\). Esto lo llevamos a un laboratorio donde el aparato de medida tiene una precisión relativa de seis cifras decimales.\n\n¿Podemos usar el resultado de este cálculo para comparar con el experimento?\nSi queremos reducir el tamaño que ocupa el número en la memoria RAM, ¿podemos cambiar nuestra representación a una de 32 bits?",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Representación de números y condicionamiento"
    ]
  },
  {
    "objectID": "04_numeros_y_condicionamiento.html#tarea-2.2",
    "href": "04_numeros_y_condicionamiento.html#tarea-2.2",
    "title": "Clase 4: Representación de números y número de condicionamiento",
    "section": "Tarea 2.2",
    "text": "Tarea 2.2\nEjercicio 1.2.3 del libro “Fundamentals of Numerical Computation: Julia Edition” de Driscoll y Braun.\nCalcule el número de condicionamiento para cada una de las siguientes funciones e identifique todos los valores de \\(x\\) para los cuales \\(\\kappa_f(x) \\rightarrow \\infty\\) (incluyendo posiblemente los límites \\(x \\rightarrow \\pm \\infty\\))\n\n\\(f(x) = \\tanh(x)\\).\n\\(f(x) = \\frac{e^x - 1}{x}\\).\n\\(f(x) = \\frac{1 - \\cos(x)}{x}\\).",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Representación de números y condicionamiento"
    ]
  },
  {
    "objectID": "04_numeros_y_condicionamiento.html#tarea-2.3",
    "href": "04_numeros_y_condicionamiento.html#tarea-2.3",
    "title": "Clase 4: Representación de números y número de condicionamiento",
    "section": "Tarea 2.3",
    "text": "Tarea 2.3\nEn ciertos cálculos importantes en cosmología surge un problema análogo al siguiente. Queremos calcular algunas integrales\n\\[\nI_{1} = \\int_{0}^{q_{max}} q^2\\left(\\frac{1}{q^5} + \\frac{3}{q}\\right)\\,dq\n\\]\n\\[\nI_{2} = \\int_{0}^{q_{max}} q^2\\left(\\frac{-1}{q^5} + \\frac{1}{q}\\right)\\,dq\n\\]\nEstas integrales se pueden aproximar numéricamente por medio de su suma\n\\[\n\\int_0^{q_{max}} f(q)\\,dq \\approx \\frac{q_{max}}{N} \\sum_{i = 1}^{N} f\\left(i\\times\\frac{q_{max}}{N}\\right)\n\\]\nProfundizaremos en el cálculo numérico de integrales más adelante.\nLa cantidad de interés es \\(I = I_{1} + I_{2}\\).\n\nUsando \\(q_{max} = 0.1\\) y \\(N = 500000\\), calcule ambas integrales por separado usando la aproximación, y luego súmelas.\nLa suma de las integrales \\(I\\) se puede escribir como la integral de la suma de los integrandos:\n\n\\[\nI = \\int_0^{q_{max}} q^2 \\frac{4}{q}\\,dq\n\\]\nCalcule \\(I\\) de esta manera usando la aproximación.\n\n¿Por qué son diferentes los resultados? Compare con el resultado exacto de la integral \\(I\\).",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Representación de números y condicionamiento"
    ]
  },
  {
    "objectID": "04_numeros_y_condicionamiento.html#tarea-2.4",
    "href": "04_numeros_y_condicionamiento.html#tarea-2.4",
    "title": "Clase 4: Representación de números y número de condicionamiento",
    "section": "Tarea 2.4",
    "text": "Tarea 2.4\nEjercicio 1.3.1 del libro de Burden: Use números de punto flotante de 16 bits para calcular las siguientes sumas. Explique por qué ambos métodos en cada caso dan resultados diferentes y cuál es la más correcta.\n\n\\(\\sum_{n = 1}^{100}\\frac{1}{n^2}\\) primero de la forma \\(1 + \\frac{1}{4} + \\frac{1}{9} + \\dots + \\frac{1}{10^4}\\) y luego en la forma \\(\\frac{1}{10^4} + \\dots + \\frac{1}{9} + \\frac{1}{4} + 1\\).\n\\(\\sum_{n = 1}^{100}\\frac{1}{n^3}\\) primero de la forma \\(1 + \\frac{1}{8} + \\frac{1}{27} + \\dots + \\frac{1}{10^6}\\) y luego en la forma \\(\\frac{1}{10^6} + \\dots + \\frac{1}{27} + \\frac{1}{8} + 1\\).",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Representación de números y condicionamiento"
    ]
  },
  {
    "objectID": "04_numeros_y_condicionamiento.html#tarea-2.5",
    "href": "04_numeros_y_condicionamiento.html#tarea-2.5",
    "title": "Clase 4: Representación de números y número de condicionamiento",
    "section": "Tarea 2.5",
    "text": "Tarea 2.5\nEjercicio 1.2.6 del libro “Fundamentals of Numerical Computation: Julia Edition” de Driscoll y Braun.\nEncuentre el número de condicionamiento para el problema de encontrar las raices del polinomio cuadrático \\(p(x) = ax^2 + bx + c\\) bajo cambios al coeficiente \\(b\\).",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Representación de números y condicionamiento"
    ]
  },
  {
    "objectID": "05_algoritmos_y_estabilidad.html",
    "href": "05_algoritmos_y_estabilidad.html",
    "title": "Clase 5: Algoritmos y estabilidad",
    "section": "",
    "text": "Evaluamos los algoritmos según tres criterios: Eficiencia, convergencia y estabilidad.\n\nEficiciencia de los algoritmos\nPara cálculos pesados, es necesario estimar la eficiencia del algoritmo. A veces cálculos que parecen inocentes se hacen demasiado pesadoos incluso para un computador.\nPara analizar la eficiencia de un algoritmo se estima el número de pasos involucrados. Por ejemplo:\n\nsuma = 0\nn = 100\nfor i in range(n):\n    suma += i\n\n\nsuma = sum(range(n))\n\nEste algoritmo toma \\(n\\) pasos, ya que debe realizar \\(n\\) operaciones. Decimos que su eficiencia es de orden \\(\\mathcal{O}(n)\\).\nA veces es necesario anidar ciclos, esto empieza a aumentar el número de pasos\n\nsuma = 0\nn = 100\nfor i in range(n):\n    for j in range(i):\n        suma += j\n\nEste algoritmo toma mucho más tiempo porque el primer ciclo toma \\(n\\) pasos y el siguiente toma \\(i\\) pasos, Como \\(i\\) puede llegar hasta \\(n(n-1)/2\\) pasos. Cuando \\(n\\) es un número muy grande esto es aproximadamente igual a \\(n^2/2\\). En este caso decimos que la eficiencia del algoritmo es del orden \\(\\mathcal{O}(n^2)\\).\nA los algoritmos con una eficiencia de orden \\(\\mathcal{O}(n^c)\\), donde \\(c\\) es una constante numérica, se los llama algoritmos de eficiencia polinomial.\nLos algoritmos más eficientes posibles son los que tienen una eficiencia logarítmica \\(\\mathcal{O}(\\log n)\\) (y en informática normalmente se usa el logaritmo base \\(2\\) en este contexto. Veremos un ejemplo de uno de estos algoritmos próximamente.\nLos peores algoritmos son los que tienen un crecimiento exponencial, por ejemplo \\(\\mathcal{O}(2^n)\\), Estos se hacen extremadamente difíciles de ejecutar para un computado incluso para valores modestos de \\(n\\).\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nn = np.arange(1,50)\nlog = np.log(n)/np.log(2)\npol2 = n**2\npol4 = n**4\nexp = 2**n\n\nplt.scatter(n, log, label = '$\\log_2$')\nplt.scatter(n, pol2, label = '$n^2$')\nplt.scatter(n, pol4, label = '$n^4$')\nplt.scatter(n, exp, label = 'exp')\nplt.legend()\n\n&lt;&gt;:10: SyntaxWarning: invalid escape sequence '\\l'\n&lt;&gt;:10: SyntaxWarning: invalid escape sequence '\\l'\n/tmp/ipykernel_294016/2146404212.py:10: SyntaxWarning: invalid escape sequence '\\l'\n  plt.scatter(n, log, label = '$\\log_2$')\n\n\n\n\n\n\n\n\n\n\n\nPrecisión y convergencia de los algoritmos\nAdemás de la eficiencia de un algoritmo, también es importante su precisión. Los métodos numéricos consisten en encontrar soluciones aproximadas a los problemas y será importante tener una estimacióon del error cometido. El error cometido en un algoritmo numérico nos da una idea de su precisión. Si el error disminuye a medida que se ejecuta un algoritmo de más pasos, decimos que converge.\nEl método numérico normalmente consiste en encontrar una sucesión de números que convergen al resultado requerido. Supongamos que tenemos una cierta sucesión \\(\\{\\alpha_n\\}\\) que converge al resultado \\(\\alpha\\). Por otra parte supongamos que tenemos otra sucesión \\(\\{\\beta_n\\}\\) que converge a cero. Decimos que el algoritmo converge a \\(\\alpha\\) a una razón \\(\\mathcal{O}(\\beta_n)\\) si se cumple que\n\\[\n|\\alpha_n - \\alpha| &lt; K|\\beta_n|\\,,\n\\]\npara alguna constante \\(K\\).\nNormalmente se toma \\(\\beta_n = 1/n^c\\) para alguna potencia \\(c\\). Los algoritmos que convergen más rápido tienen \\(c\\) alto.\nPor ejemplo, consideremos la sucesión \\(\\{n \\sin(1/n)\\}\\), esta converge a \\(1\\) a medida que \\(n\\) crece. Otra sucesión que converge a \\(1\\) es \\(\\{1 - 1/n\\}\\).\n\nsuc1 = []\nsuc2 = []\nfor n in range(1,101):\n    suc1.append(1 - n*np.sin(1/n))\n    suc2.append(1/n)\n\n\nplt.scatter(np.arange(1,101), suc1)\nplt.scatter(np.arange(1,101), suc2)\n\n\n\n\n\n\n\n\n\nplt.loglog(np.arange(1,101), suc1)\nplt.loglog(np.arange(1,101), suc2)\n\n\n\n\n\n\n\n\nOtro ejemplo es un algoritmo para calcular \\(\\pi\\), llamada fórmula de Leibniz\n\\[\n\\pi = 4 - \\frac{4}{3} + \\frac{4}{5} - \\frac{4}{7} + \\frac{4}{9} - \\dots\n\\]\n(Esto viene del hecho que \\(\\pi/4 = \\tan^{-1}(1)\\) al hacer la expanción de Taylor de la tangente inversa).\nComparada con otra fórmula que converge más rápidamente\n\\[\n\\pi = 3 + \\frac{4}{2\\times 3\\times 4} - \\frac{4}{4\\times 5 \\times 6} + \\frac{4}{6\\times 7\\times 8} - \\dots\n\\]\n\npi1 = [4]\npi2 = [3]\n\nfor n in range(1, 100):\n    pi1.append(pi1[n-1] + (-1)**n*4/(2*n + 1))\n    pi2.append(pi2[n-1] + (-1)**(n + 1)*4/(2*n*(2*n + 1)*2*(n+1)))\n    \nplt.loglog(np.arange(100), pi1, label='pi1')\nplt.loglog(np.arange(100), pi2, label = 'pi2')\nplt.loglog(np.arange(100), np.full(100, np.pi), label = 'pi verdadero')\nplt.legend()\nplt.xlim(10**1, 10**2)\nplt.ylim(np.pi - 0.001*np.pi, np.pi + 0.001*np.pi)\n\n\n\n\n\n\n\n\n\n\nEstabilidad de los algoritmos\nEn algunos casos el problema que queremos resolver tiene un buen número de condicionamiento, pero el algoritmo da errores grandes al perturbar los datos de entrada. En estos casos decimos que el algoritmo es inestable. Esta inestabilidad puede tener varios orígenes: Acumulación de errores de redondeo (ver tarea 2.4), número de condicionamiento grande de los pasos intermedios del algoritmo, entre otros.\nHagamos un ejemplo: Consideremos el polinomio \\(p(x) = (x - 10^6)(x - 10^{-6})\\). Como las dos raíces son muy distintas sabemos que es un problema bien condicionado (ver clase anterior). Sin embargo, al intentar evaluar las raíces usando la formulita estándar obtenemos\n\nimport math\n\na = 1\nb = -(1e6 + 1e-6)\nc = 1\nx1 = (-b + math.sqrt(b**2 - 4*a*c)) / (2*a)\nx2 = (-b - math.sqrt(b**2 - 4*a*c)) / (2*a)\nprint(f\"Raíz 1: {x1}, Raíz 2: {x2}\")\n\nRaíz 1: 1000000.0, Raíz 2: 1.00000761449337e-06\n\n\nLa raíz 1 es exacta. Sin embargo la raíz 2 tiene sólo 7 cifras decimales de precisión (no las 15 que nos promete la aritmética de 64 bits). ¿Qué pasa aqí?\nPara calcular x2 tenemos que hacer la resta de\n\n-b\n\n1000000.000001\n\n\ncon\n\nmath.sqrt(b**2 - 4*a*c)\n\n999999.999999\n\n\nVemos que son dos cantidades cercanas. Esto tiene un mal número de condicionamiento y se pierden cifras decimales de precisión. La formulita es inestable.\nPara resolver este problema podemos usar el hecho que \\(x_1 x_2 = c/a\\) y entonces\n\nx2 = c/a/x1\nprint(f\"Raíz 2: {x2}\")\n\nRaíz 2: 1e-06\n\n\nEl problema estaba bien condicionado tal que podemos encontrar una buena solución, pero el algoritmo usado inicialmente es inestable.\nEl término “inestable” también se usa para los algoritmos que no convergen a la solución correcta cuando se aumenta la precisión. Esto puede suceder, por ejemplo, si el algoritmo depende de operaciones que amplifican errores de redondeo o si el número de condicionamiento de los pasos intermedios es grande.\n\n\n¡Tareas!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Acerca de este sitio",
    "section": "",
    "text": "Versión: 0.0.1 (trabajo en progreso)\nEstas son las notas de clases del curso de Métodos Numéricos y Probabilidades 2025. El curso es parte del plan de estudios de la licenciatura en física de la Pontificia Universidad Católica de Valparaíso, Chile. Dictado por el profesor Jorge Noreña, el curso cubre temas fundamentales de métodos numéricos y probabilidad aplicados a la física.\nUna pequeña parte de estos apuntes fue escrita con la ayuda de inteligencia artificial, revisado y corregido por el profesor."
  },
  {
    "objectID": "01_funcionamiento_cpu.html",
    "href": "01_funcionamiento_cpu.html",
    "title": "¿Cómo funciona un computador?",
    "section": "",
    "text": "Lo que hace un computador es mover un montón de electrones. Para entender el computador, debemos entender cómo se mueven estas partículas en diferentes materiales. No entraremos en muchos detalles, pero necesitamos un par de hechos\n\nLos portadores de carga son los electrones: Los protones también tienen carga, pero son mucho más pesados y difíciles de mover. Las corrientes eléctricas consisten en electrones débilmente ligados que se mueven de un lugar a otro.\nEl principio de exclusión de Pauli: Dos electrones no pueden tener el mismo estado. Si tenemos un átomo completamente ionizado (sin electrones) y le agregamos un electrón, éste tenderá a ocupar el estado de mínima energía. Al llegar un segundo electrón, no puede estar en el mismo estado, así que ocupa otro. A medida que llenamos el átomo de electrones, estos ocuparán estados de energías más altas (menos ligados al átomo).\nAl poner muchos átomos juntos en un material, los niveles de energía se mezclan formando bandas de energía. Estas bandas pueden acomodar muchos electrones. La energía máxima ocupada por un electrón cuando llenamos el material ignorando los efectos de la temperatura se llama energía de Fermi. Las bandas de energía por encima de las de Fermi están vacías a bajas temperaturas.\nSi la energía de Fermi cae en el medio de una banda de energía, el material es un conductor. Los electrones pueden adquirir un poco de energía cinética sin salirse de la banda y así moverse por el material.\nSi la energía de Fermi cae en la separación de dos bandas, el material es un aislante. Si un electrón quiere moverse, debe adquirir un poco de energía cinética, pero no puede ya que su banda está llena. A ese electrón le queda difícil adquirir suficiente energía cinética para pasar de la última banda llena a la primera banda vacía.\n\n\n\nUn semiconductor es un aislante pero tal que la última banda llena está muy cerca de la primera banda vacía.\nNormalmente los semiconductores se dopan. Es decir, se les agrega una pequeña cantidad de átomos diferentes a los del material, pero que se encuentran cercanos en la tabla periódica.\nEsto quiere decir que esos átomos de dopaje les sobra o les falta un electrón respecto a los del material. Cuando les falta un electrón, se dice que son de tipo p, cuando les sobra uno son de tipo n.\nA continuación vemos el estado de las bandas de conducción para diferentes tipos de materiales. Cuando una banda tiene una región semillena (gris), esta puede conducir electricidad fácilmente. (Fuente: Wikipedia)\n\n\n¿Para qué sirve eso? Una aplicación sencilla son los diodos. Estos consisten en una juntura de un semiconductor tipo p con uno de tipo n. Los electrones sobrantes en el tipo n pueden viajar hacia el tipo p para llenar los huecos presentes en este. Pero si se aplica un voltaje en la dirección opuesta, no puede pasar corriente. El diodo deja pasar corriente en una sola dirección.\nTambién sirven para hacer transistores, que son las componentes fundamentales del computador.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Funcionamiento de la CPU"
    ]
  },
  {
    "objectID": "01_funcionamiento_cpu.html#semiconductores",
    "href": "01_funcionamiento_cpu.html#semiconductores",
    "title": "¿Cómo funciona un computador?",
    "section": "",
    "text": "Un semiconductor es un aislante pero tal que la última banda llena está muy cerca de la primera banda vacía.\nNormalmente los semiconductores se dopan. Es decir, se les agrega una pequeña cantidad de átomos diferentes a los del material, pero que se encuentran cercanos en la tabla periódica.\nEsto quiere decir que esos átomos de dopaje les sobra o les falta un electrón respecto a los del material. Cuando les falta un electrón, se dice que son de tipo p, cuando les sobra uno son de tipo n.\nA continuación vemos el estado de las bandas de conducción para diferentes tipos de materiales. Cuando una banda tiene una región semillena (gris), esta puede conducir electricidad fácilmente. (Fuente: Wikipedia)\n\n\n¿Para qué sirve eso? Una aplicación sencilla son los diodos. Estos consisten en una juntura de un semiconductor tipo p con uno de tipo n. Los electrones sobrantes en el tipo n pueden viajar hacia el tipo p para llenar los huecos presentes en este. Pero si se aplica un voltaje en la dirección opuesta, no puede pasar corriente. El diodo deja pasar corriente en una sola dirección.\nTambién sirven para hacer transistores, que son las componentes fundamentales del computador.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Funcionamiento de la CPU"
    ]
  },
  {
    "objectID": "01_funcionamiento_cpu.html#qué-es-un-transistor",
    "href": "01_funcionamiento_cpu.html#qué-es-un-transistor",
    "title": "¿Cómo funciona un computador?",
    "section": "¿Qué es un transistor?",
    "text": "¿Qué es un transistor?\nUn transistor es un componente electrónico que tiene tres “cables”. Para nuestros propósitos aquí podemos pensar en él como un switch: Cuando el voltaje en un cable supera un cierto valor (Típicamente \\(5\\,\\text{V}\\)), puede pasar corriente entre los otros dos cables.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Funcionamiento de la CPU"
    ]
  },
  {
    "objectID": "01_funcionamiento_cpu.html#cómo-funciona-físicamente",
    "href": "01_funcionamiento_cpu.html#cómo-funciona-físicamente",
    "title": "¿Cómo funciona un computador?",
    "section": "¿Cómo funciona físicamente?",
    "text": "¿Cómo funciona físicamente?\nEl transistor más usado es el de efecto campo. Consiste en semiconductores de tipo n y p en la siguiente configuración:\nHay una diferencia de potencial entre el lado izquierdo y el derecho, pero la corriente no puede pasar debido al mismo efecto que en el díodo.\nPero si en el cable del medio se aplica un potencial positivo que atrae electrones, eso elimina los huecos del semiconductor tipo p y crea un canal por el cual puede fluir la corriente.\nEste es un diagrama del transistor de efecto de campo (Fuente: Wikipedia):\n\n\nEl símbolo del transistor es el siguiente (Fuente: Wikipedia)\n\n\nCuando hay voltaje en la compuerta, la corriente puede fluir entre la fuente y el drenaje.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Funcionamiento de la CPU"
    ]
  },
  {
    "objectID": "01_funcionamiento_cpu.html#compuerta-and",
    "href": "01_funcionamiento_cpu.html#compuerta-and",
    "title": "¿Cómo funciona un computador?",
    "section": "Compuerta AND",
    "text": "Compuerta AND\nEste es el diagrama de la compuerta que implementa la operación booleana y (Fuente: Wikipedia)\n\n\nRepresenta la operación \\(A\\wedge B = Q\\).\nSe puede realizar mediante transistores de la siguiente manera\n\n\nFuente: http://hyperphysics.phy-astr.gsu.edu/hbase/Electronic/trangate.html",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Funcionamiento de la CPU"
    ]
  },
  {
    "objectID": "01_funcionamiento_cpu.html#compuerta-or",
    "href": "01_funcionamiento_cpu.html#compuerta-or",
    "title": "¿Cómo funciona un computador?",
    "section": "Compuerta OR",
    "text": "Compuerta OR\nEste es el diagrama de la compuerta que implementa la operación booleana o (Fuente: Wikipedia)\n\n\nRepresenta la operación \\(A\\vee B = Q\\).\nSe puede realizar mediante transistores de la siguiente manera\n\n\nFuente: http://hyperphysics.phy-astr.gsu.edu/hbase/Electronic/trangate.html",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Funcionamiento de la CPU"
    ]
  },
  {
    "objectID": "01_funcionamiento_cpu.html#compuerta-nand",
    "href": "01_funcionamiento_cpu.html#compuerta-nand",
    "title": "¿Cómo funciona un computador?",
    "section": "Compuerta NAND",
    "text": "Compuerta NAND\nEste es el diagrama de la compuerta que implementa la operación booleana no y (Fuente: Wikipedia)\n\n\nRepresenta la operación \\(\\neg(A\\wedge B) = Q\\).\nSe puede realizar mediante transistores de la siguiente manera\n\n\nFuente: http://hyperphysics.phy-astr.gsu.edu/hbase/Electronic/trangate.html\nEsta compuerta es muy importante ya que es una compuerta universal: Cualquier otra compuerta se puede construir combinando NANDs. Por ejemplo implementa la compuerta NOT mediante \\(\\neg A = \\neg(A \\wedge A)\\).",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Funcionamiento de la CPU"
    ]
  },
  {
    "objectID": "01_funcionamiento_cpu.html#compuerta-xor",
    "href": "01_funcionamiento_cpu.html#compuerta-xor",
    "title": "¿Cómo funciona un computador?",
    "section": "Compuerta XOR",
    "text": "Compuerta XOR\nEste es el diagrama de la compuerta que implementa la operación booleana no exclusivo (Fuente: Wikipedia)\n\n\nRepresenta la operación \\(A \\oplus B = Q\\), que tiene la siguiente tabla de verdad\n\n\n\nA\nB\nQ\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\nComo realizarla con transistores se deja como un ejercicio opcional para el estudiante.\nEsta compuerta corresponde al uso corriente de la palabra “o” en español. Es decir, es verdad cuando uno u otro es verdad, pero no cuando ambos lo son.\nSerá importante en la siguiente sección.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Funcionamiento de la CPU"
    ]
  },
  {
    "objectID": "01_funcionamiento_cpu.html#binarios",
    "href": "01_funcionamiento_cpu.html#binarios",
    "title": "¿Cómo funciona un computador?",
    "section": "Binarios",
    "text": "Binarios\nEl computador combina \\(1\\) y \\(0\\) para formar números. Es decir que usa una base binaria.\nEstamos acostumbrados a la base decimal en la cual los dígitos van de \\(0\\) a \\(9\\). Cuando llegamos a un número mayor que \\(9\\), necesitamos un nuevo dígito que representa las decenas y así sucesivamente.\nEn la base binaria, tenemos sólo los dígitos \\(0\\) y \\(1\\) que se pueden trabajar como voltajes en los circuitos que vimos arriba. Esto quiere decir que el número \\(10\\) en binario representa el número \\(2\\) en decimal. Por el contrario, el número \\(10\\) en decimal se escribe \\(1010\\) en binario.\nSe recomienda que la estudiante intente escribir por su cuenta algunos números más en base binaria.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Funcionamiento de la CPU"
    ]
  },
  {
    "objectID": "01_funcionamiento_cpu.html#la-media-suma",
    "href": "01_funcionamiento_cpu.html#la-media-suma",
    "title": "¿Cómo funciona un computador?",
    "section": "La media suma",
    "text": "La media suma\nEmpezamos por el elemento más sencillo: Sumar dos números enteros positivos binarios de un solo dígito.\nPara sumar los números \\(A\\) y \\(B\\) guardamos el resultado en \\(S\\) que también tiene un solo dígito. Si el resultado tiene más de un dígito, el dígito adicional “se lleva” guardándolo en \\(C\\). De esta manera\n\n\n\nA\nB\nS\nC\n\n\n\n\n0\n0\n0\n0\n\n\n0\n1\n1\n0\n\n\n1\n0\n1\n0\n\n\n1\n1\n0\n1\n\n\n\nNote que \\(S = A\\oplus B\\) y que \\(C = A \\wedge B\\), tal que esto se puede lograr con el siguiente circuito (Fuente: Wikipedia)\n\n\nA un chip que realiza esto lo representamos mediante",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Funcionamiento de la CPU"
    ]
  },
  {
    "objectID": "01_funcionamiento_cpu.html#sumador-completo",
    "href": "01_funcionamiento_cpu.html#sumador-completo",
    "title": "¿Cómo funciona un computador?",
    "section": "Sumador completo",
    "text": "Sumador completo\nAhora nos preguntamos qué pasa si estamos sumando dos dígitos binarios, pero además queremos sumar un tercero que se “lleva” de la suma de dígitos anteriores. Ahora tenemos tres binarios \\(A\\), \\(B\\), \\(C_{in}\\) con la siguiente tabla de verdad\n\n\n\n\\(A\\)\n\\(B\\)\n\\(C_{in}\\)\n\\(S\\)\n\\(C_{out}\\)\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n1\n0\n\n\n0\n1\n0\n1\n0\n\n\n0\n1\n1\n0\n1\n\n\n1\n0\n0\n1\n0\n\n\n1\n0\n1\n0\n1\n\n\n1\n1\n0\n0\n1\n\n\n1\n1\n1\n1\n1\n\n\n\nUn posible circuito que lo logra es (fuente: Wikipedia)\n\n\nUn chip que realiza esto lo podemos denotar",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Funcionamiento de la CPU"
    ]
  },
  {
    "objectID": "01_funcionamiento_cpu.html#suma-de-varios-dígitos",
    "href": "01_funcionamiento_cpu.html#suma-de-varios-dígitos",
    "title": "¿Cómo funciona un computador?",
    "section": "Suma de varios dígitos",
    "text": "Suma de varios dígitos\nAhora podemos encadenar varios chips de estos para sumar un número de cuatro bits (cuatro dígitos binarios)\n\n\nEste es sólo un ejemplo de cómo a partir de semiconductores podemos realizar operaciones aritméticas.\nLos procesadores modernos trabajan con números de 64 bits, realizando operaciones como esta miles de millones de veces por segundo. Obviamente no usan solamente números enteros positivos, también usan números decimales (llamados de punto flotante) que estudiaremos en un par de clases.",
    "crumbs": [
      "Inicio",
      "Unidad 1: Introducción",
      "Funcionamiento de la CPU"
    ]
  }
]